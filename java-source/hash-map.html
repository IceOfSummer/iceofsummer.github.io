
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>HashMap源码 | IceOfSummerの博客</title>
        <meta name="author" content="IceOfSummer" />
        <meta name="description" content="用来用去还是自己搭的博客靠谱" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="https://selfb.asia/static/particlex/static/fonts.min.css" />
<script>
  const mixins = {};
  const h = (arg1, arg2, arg3) => {
    if (arg2.attrs) {
      Object.assign(arg2, arg2.attrs)
      Reflect.deleteProperty(arg2, 'attrs')
    }
    if (arg2.on) {
      Object.keys(arg2.on).forEach(key => {
        const head = key.charAt(0).toUpperCase()
        arg2['on' + head  + key.substring(1)] = arg2.on[key]
      })
      Reflect.deleteProperty(arg2, 'on')
    }
    return Vue.h(arg1, arg2, arg3)
  }
</script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

  <script src="/js/lib/toc.js"></script>



  <script src="/js/lib/lazy-load-support.js"></script>


    <meta name="generator" content="Hexo 7.1.1"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存&ensp;浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            </transition>
            <transition name="into">
            <div id="main" v-show="!loading">
                <nav id="menu" ref="menu">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>ICEOFSUMMERの博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" v-show="showMenu" @click="showMenu = !showMenu"></div>
        <div class="title" @click="showMenu = !showMenu">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ICEOFSUMMERの博客</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenu">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

                <div class="article">
    <div>
        <h1>HashMap源码</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/7
        </span>
        
        <span class="category">
            <a href="/2023/03/05/java-source/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Java源码
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            <span class="tag">
                
                <a href="/2023/03/05/java-source#Java" style="color: #03a9f4">Java</a>
            </span>
            
        </span>
        
    </div>
    
    <toc-component></toc-component>
    <div class="content" v-pre id="main-content">
        <p>HashMap在jdk8前是由数组+链表实现的，也就是数据结构上非常经典的实现操作：</p>
<p>假如元素的的哈希值为<code>hash</code>，数组长度为<code>len</code>，那么该元素应该放在<code>hash % len</code>处</p>
<ul>
<li>若该位置没有元素，则直接放进去</li>
<li>若该位置有元素，则直接将该元素放到链表后(如果该元素不是链表则要新建一个链表)</li>
</ul>
<p>在jdk8中，若链表过长，则会将链表转换为红黑树(本篇不讲红黑树原理，因为我也不会2333，只需要知道是一个平衡树即可，搜索效率一般为<code>log(n)</code>。</p>
<p>接下来我将根据自己的理解，一步一步阅读HashMap源码(我使用的是jdk11，与java8应该不会有太大差距)。</p>
<h1 id="1-构造器"><a href="#1-构造器" class="headerlink" title="1. 构造器"></a>1. 构造器</h1><p>HashMap有四个构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &amp;lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &amp;gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &amp;lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&amp;lt;? extends K, ? extends V&amp;gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现其中出现了两个属性：<code>loadFactor(负载因子)</code>和<code>threshold(扩容阈值)</code></p>
<p>首先需要知道这样一个关系：<code>threshold = loadFactor * capacity</code></p>
<p>其中<code>capacity</code>为整个Hash表数组长度，当<code>size(插入到HashMap中元素的个数) &amp;gt; threshold</code>时，就会对HashMap进行扩容。</p>
<p>可以发现，除了第四个构造器，其它3个其实都没有对Hash表数组进行初始化，只是设置了扩容阈值和负载因子而已。</p>
<h2 id="1-1-tableSizeFor"><a href="#1-1-tableSizeFor" class="headerlink" title="1.1 tableSizeFor"></a>1.1 tableSizeFor</h2><p>第一个构造器中，在给threshold赋值前，还调用了tableSizeFor方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java11</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &amp;gt;&amp;gt;&amp;gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &amp;lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java8</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//移位运算</span></span><br><span class="line">    n |= n &amp;gt;&amp;gt;&amp;gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &amp;gt;&amp;gt;&amp;gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &amp;gt;&amp;gt;&amp;gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &amp;gt;&amp;gt;&amp;gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &amp;gt;&amp;gt;&amp;gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &amp;lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体可以看这篇文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiyixiaodao/p/14483876.html">HashMap之tableSizeFor方法图解 - 希夷小道 - 博客园 (cnblogs.com)</a></p>
<p>这个方法的主要目的是返回一个最小的，并且大于等于<code>cap</code>的2次幂。</p>
<p>为什么要二次幂呢？这里需要了解一个小知识：</p>
<p>假设<code>k</code>为2的幂，那么对于任意一个数(非负)<code>m</code>，有：<code>m &amp; (k - 1) = m % k</code></p>
<p>其实也不难理解，比如<code>10101(21)</code>对<code>1000(8)</code>取余，结果为5，很明显，对于<code>1000</code>左边(包括)所有的位，它都能够整除，因为都是2的幂，而对于右边不难整除，所以就一定是余数了，减一个1变成<code>0111</code>，再取并，就可以得到右边的余数了。</p>
<p>在Java11中，主要通过<code>Integer.numberOfLeadingZeros</code>获取最高位1的左边有几个0，然后再对<code>-1</code>进行无符号位移得到结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numberOfLeadingZeros</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// HD, Count leading 0&#x27;s</span></span><br><span class="line">    <span class="keyword">if</span> (i &amp;lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">32</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">		<span class="comment">// 这里类似二分搜索</span></span><br><span class="line">    <span class="keyword">if</span> (i &amp;gt;= <span class="number">1</span> &amp;lt;&amp;lt; <span class="number">16</span>) &#123; n -= <span class="number">16</span>; i &amp;gt;&amp;gt;&amp;gt;= <span class="number">16</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &amp;gt;= <span class="number">1</span> &amp;lt;&amp;lt;  <span class="number">8</span>) &#123; n -=  <span class="number">8</span>; i &amp;gt;&amp;gt;&amp;gt;=  <span class="number">8</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &amp;gt;= <span class="number">1</span> &amp;lt;&amp;lt;  <span class="number">4</span>) &#123; n -=  <span class="number">4</span>; i &amp;gt;&amp;gt;&amp;gt;=  <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &amp;gt;= <span class="number">1</span> &amp;lt;&amp;lt;  <span class="number">2</span>) &#123; n -=  <span class="number">2</span>; i &amp;gt;&amp;gt;&amp;gt;=  <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> n - (i &amp;gt;&amp;gt;&amp;gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-put"><a href="#2-put" class="headerlink" title="2. put"></a>2. put</h1><p><code>put</code>其实是调用了内部的<code>putVal</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value(如果为ture，当插入相同的key时不会进行替换)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode(如果为false，表示哈希表为创建模式)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">		Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; <span class="type">int</span> n, i;</span><br><span class="line">		<span class="comment">// 在这里将哈希表赋值给tab</span></span><br><span class="line">		<span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">			<span class="comment">// 到这里表示hash表没有初始化，在这里进行扩容</span></span><br><span class="line">		    n = (tab = resize()).length;</span><br><span class="line">		<span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">			<span class="comment">// 当前位置没有节点，直接插入</span></span><br><span class="line">		    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 到这里说明当前位置有节点，p就是那个节点</span></span><br><span class="line">			<span class="comment">// 这里的e代表：若有相同的key，则用变量e暂时保存下来，再根据onlyIfAbsent参数考虑是否替换</span></span><br><span class="line">		    Node&amp;lt;K,V&amp;gt; e; K k;</span><br><span class="line">		    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">		        ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">				<span class="comment">// 相同的key，考虑是否替换</span></span><br><span class="line">		        e = p;</span><br><span class="line">		    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">				<span class="comment">// p是一个树的根节点，把新节点插入到树里，该方法会返回之前的旧值，如果没有则返回null</span></span><br><span class="line">		        e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">		    <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// p链表头部，遍历到尾部后进行插入</span></span><br><span class="line">		        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">		            <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">		                p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">						<span class="comment">// **如果链表节点数量超过TREEIFY_THRESHOLD，则将链表进行树化，默认值为8**</span></span><br><span class="line">		                <span class="keyword">if</span> (binCount &amp;gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">		                    treeifyBin(tab, hash);</span><br><span class="line">		                <span class="keyword">break</span>;</span><br><span class="line">		            &#125;</span><br><span class="line">		            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">		                ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">		                <span class="keyword">break</span>;</span><br><span class="line">					<span class="comment">// 同理，出现相同的key，考虑进行替换</span></span><br><span class="line">		            p = e;</span><br><span class="line">		        &#125;</span><br><span class="line">		    &#125;</span><br><span class="line">			<span class="comment">// 判断是否有旧值</span></span><br><span class="line">		    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">		        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">		        <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">					<span class="comment">// 进行替换</span></span><br><span class="line">		            e.value = value;</span><br><span class="line">		        afterNodeAccess(e);</span><br><span class="line">		        <span class="keyword">return</span> oldValue;</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		++modCount;</span><br><span class="line">		<span class="comment">// 在这里判断总节点数是否超过阈值，若超过则进行扩容</span></span><br><span class="line">		<span class="keyword">if</span> (++size &amp;gt; threshold)</span><br><span class="line">		    resize();</span><br><span class="line">		afterNodeInsertion(evict);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-resize"><a href="#3-resize" class="headerlink" title="3. resize"></a>3. resize</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&amp;lt;K,V&amp;gt;[] resize() &#123;</span><br><span class="line">	<span class="comment">// 首先保存好旧哈希表</span></span><br><span class="line">    Node&amp;lt;K,V&amp;gt;[] oldTab = table;</span><br><span class="line">	<span class="comment">// 旧的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">	<span class="comment">// 旧的阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">	<span class="comment">// 新的容量和阈值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 如果旧容量大于0，说明已经初始化过了</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &amp;gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果超过容量最大值，则不再进行扩容，即将扩容阈值设置为Int最大值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &amp;gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 这里将容量乘2，至于后面那个判断意义不是很明确，因为后面也有关于newThr的判断</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &amp;lt;&amp;lt; <span class="number">1</span>) &amp;lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &amp;lt;&amp;lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 因为之前判断过oldCap是否大于0，所以到这里oldCap一定等于0，因此后面的判断都是去初始化哈希表的</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &amp;gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">		<span class="comment">// 旧阈值为0，标示使用了空参构造器，并且还没有初始化</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 设置扩容阈值</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">		<span class="comment">// 防止超出上限</span></span><br><span class="line">        newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;&amp; ft &amp;lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 在这里重新计算hash，并将节点放到新的哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &amp;lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&amp;lt;K,V&amp;gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">				<span class="comment">// 如果当前节点只有一个，则直接将其移动</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">				<span class="comment">// 如果当前节点为树节点，则重新建树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&amp;lt;K,V&amp;gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">					<span class="comment">// 到这里说明当前节点是有多个节点的链表</span></span><br><span class="line">					<span class="comment">// 这里lo代表低位，hi代表高位</span></span><br><span class="line">					<span class="comment">// 因为扩容只是将capacity左移了一位，因此对于一个节点及其子节点，它们最多分散到两个位置</span></span><br><span class="line">                    Node&amp;lt;K,V&amp;gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&amp;lt;K,V&amp;gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&amp;lt;K,V&amp;gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">							<span class="comment">// 到这里说明这个节点在哈希表的位置没有变，这里为什么是用哈希值和旧容量相并判断的呢？</span></span><br><span class="line">							<span class="comment">// 因为在前面说过了，造成位置变化的唯一原因是capacity左移了一位，而我们取索引是通过hash &amp; (capacity - 1)来获得的</span></span><br><span class="line">							<span class="comment">// 所以只要在旧hash的最高位1的位置，oldCap这一位也是1，说明扩容后索引一定发生了变化</span></span><br><span class="line">							<span class="comment">// 例如旧长度为10000(16)，最高位1在第五个，对于1011010(hex)，由于它的第五位也是1，说明新hash肯定会发生变化</span></span><br><span class="line">							<span class="comment">// 新长度为100000(32)，减一后为011111(31)，后4位我们不用管，只用管第五位，和hash取并后会产生新索引。</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">					<span class="comment">// 插入链表</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容大致流程如下：</p>
<p>​	- 首先判断数是否初始化(即判断oldCap是否大于0)，如果大于0并且没有超出扩容限制，则进行扩容</p>
<p>​	- 若oldCap为0，并且oldThr大于0，此时进行初始化，直接将哈希表容量设置为oldThr</p>
<p>​	- 若上面两条都不满足，即oldCap为0，oldThr小于等于0，此时哈希表将会以默认容量初始化(16)</p>
<p>之后则是重新hash了。</p>
<p>在树的重hash中，也有一个重要参数*<code>UNTREEIFY_THRESHOLD</code>，*如果新树的节点数量小于等于该值，则会调用<code>TreeNode#untreeify</code>来链表化，这个阈值默认为6。<font color="red">这么设置主要是为了避免频繁的树化和链表化造成性能问题</font>。</p>
<p>在java7中，链表的插入采用的是头插法，在多线程环境下会产生死链，在java8后，采用了尾插法，有效的解决了死链的问题。</p>
<p>下面是java7的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &amp;lt; src.length; j++) &#123;</span><br><span class="line">        Entry&amp;lt;K,V&amp;gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&amp;lt;K,V&amp;gt; next = e.next;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-其它"><a href="#4-其它" class="headerlink" title="4. 其它"></a>4. 其它</h1><h2 id="4-1-treeifyBin"><a href="#4-1-treeifyBin" class="headerlink" title="4.1 treeifyBin"></a>4.1 treeifyBin</h2><p>链表树化的前提是哈希表的容量大于64：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&amp;lt;K,V&amp;gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&amp;lt;K,V&amp;gt; e;</span><br><span class="line">    <span class="comment">// 这里有一个判断</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &amp;lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        TreeNode&amp;lt;K,V&amp;gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&amp;lt;K,V&amp;gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 IceOfSummerの博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;IceOfSummer
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        
<script
    src="https://giscus.app/client.js"
    data-repo="IceOfSummer/iceofsummer.github.io"
    data-repo-id="R_kgDOJFU7OQ"
    data-category="Announcements"
    data-category-id="DIC_kwDOJFU7Oc4CUyC7"
    data-mapping="title"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin
    async
></script>





        
    </body>
</html>
