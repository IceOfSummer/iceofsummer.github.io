
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>ConcurrentHashMap源码 | IceOfSummerの博客</title>
        <meta name="author" content="IceOfSummer" />
        <meta name="description" content="后面一辈子的博客都在这了！" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="https://selfb.asia/static/particlex/static/fonts.min.css" />
<script>
  const mixins = {};
  const h = (arg1, arg2, arg3) => {
    if (arg2.attrs) {
      Object.assign(arg2, arg2.attrs)
      Reflect.deleteProperty(arg2, 'attrs')
    }
    if (arg2.on) {
      Object.keys(arg2.on).forEach(key => {
        const head = key.charAt(0).toUpperCase()
        arg2['on' + head  + key.substring(1)] = arg2.on[key]
      })
      Reflect.deleteProperty(arg2, 'on')
    }
    return Vue.h(arg1, arg2, arg3)
  }
</script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

  <script src="/js/lib/toc.js"></script>



  <script src="/js/lib/lazy-load-support.js"></script>


    <meta name="generator" content="Hexo 7.1.1"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存&ensp;浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            </transition>
            <transition name="into">
            <div id="main" v-show="!loading">
                <nav id="menu" ref="menu">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>ICEOFSUMMERの博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" v-show="showMenu" @click="showMenu = !showMenu"></div>
        <div class="title" @click="showMenu = !showMenu">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ICEOFSUMMERの博客</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenu">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

                <div class="article">
    <div>
        <h1>ConcurrentHashMap源码</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/7
        </span>
        
        <span class="category">
            <a href="/2023/03/05/java-source/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Java源码
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            <span class="tag">
                
                <a href="/2023/03/05/java-source#Java" style="color: #03a9f4">Java</a>
            </span>
            
        </span>
        
    </div>
    
    <toc-component></toc-component>
    <div class="content" v-pre id="main-content">
        <blockquote>
<p>本篇基于Java11</p>
</blockquote>
<p>由于<code>ConcurrentHashMap</code>比<code>HashMap</code>复杂了不止一点，个人建议自己跟着源码追，有看不懂的方法再来看我的博客。</p>
<p>省流版：</p>
<ul>
<li>loadFactor(负载因子)被固定为了0.75，且通过构造器设置只会影响初始容量</li>
<li><code>ConcurrentHashMap</code>支持并发扩容</li>
<li><code>HashMap</code>的<code>threshold</code>被替换为了<code>sizeCtl</code>，高16位代表当前哈希表容量的一个”版本号”，<code>低16位 - 1</code>表示当前正在进行扩容的线程数</li>
</ul>
<h1 id="1-构造器"><a href="#1-构造器" class="headerlink" title="1. 构造器"></a>1. 构造器</h1><pre><code class="java">public ConcurrentHashMap() &#123;
&#125;

public ConcurrentHashMap(int initialCapacity) &#123;
    this(initialCapacity, LOAD_FACTOR, 1);
&#125;

public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;
    this.sizeCtl = DEFAULT_CAPACITY;
    putAll(m);
&#125;

public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123;
    this(initialCapacity, loadFactor, 1);
&#125;

public ConcurrentHashMap(int initialCapacity,
                         float loadFactor, int concurrencyLevel) &#123;
    if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)
        throw new IllegalArgumentException();
    if (initialCapacity &lt; concurrencyLevel)   // Use at least as many bins
        initialCapacity = concurrencyLevel;   // as estimated threads
    long size = (long)(1.0 + (long)initialCapacity / loadFactor);
    int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ?
        MAXIMUM_CAPACITY : tableSizeFor((int)size);
    this.sizeCtl = cap;
&#125;
</code></pre>
<p>和我们的老朋友<code>HashMap</code>有如下不同：</p>
<ul>
<li><p><code>HashMap</code>的<code>threshold</code>扩容阈值没有了</p>
</li>
<li><p>这里新出来了一个<code>sizeCtl</code>，根据其大小有不同的含义：</p>
<ul>
<li>当该值为0时，表示正在等待哪个线程去初始化</li>
<li>当该值为负数时，表示正在初始化或者调整大小<ul>
<li>-1表示正在初始化</li>
<li>若为其他负数，<font color=red><strong>则<code>低16位 - 1</code>表示当前正在扩容的线程数</strong></font>，是的，你没看错，<code>ConcurrentHashMap</code>是支持并发扩容的！</li>
</ul>
</li>
<li>当大于0时，<font color=red>这个值就和<code>HashMap</code>的<code>threshold</code>一样的意思了，都是代表扩容阈值</font>。</li>
</ul>
</li>
<li><p>构造器多了一个<code>concurrencyLevel</code>，表示预估会有多少个写线程，实际上也没什么用，就是一个局部变量。</p>
</li>
</ul>
<h1 id="2-put"><a href="#2-put" class="headerlink" title="2. put"></a>2. put</h1><p>在看<code>put</code>之前还需要了解其它一些方法。</p>
<h2 id="2-1-initTable"><a href="#2-1-initTable" class="headerlink" title="2.1 initTable"></a>2.1 initTable</h2><pre><code class="java">/**
 * Initializes table, using the size recorded in sizeCtl.
 */
private final Node&lt;K,V&gt;[] initTable() &#123;
    Node&lt;K,V&gt;[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) &#123;
        // 前面说过了，sizeCtl小于0表示正在初始化，这里说明有别的线程正在初始化
        if ((sc = sizeCtl) &lt; 0)
            // 让当前线程主动放弃CPU
            Thread.yield(); // lost initialization race; just spin
        // 在这里进行CAS修改sizeCtl为-1
        else if (U.compareAndSetInt(this, SIZECTL, sc, -1)) &#123;
            try &#123;
                if ((tab = table) == null || tab.length == 0) &#123;
                    // n表示新哈希表容量，默认容量还是16
                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings(&quot;unchecked&quot;)
                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
                    table = tab = nt;
                    // 这里可以理解为 sc = n * 0.75. 向右位移2位等于除以4
                    sc = n - (n &gt;&gt;&gt; 2);
                &#125;
            &#125; finally &#123;
                sizeCtl = sc;
            &#125;
            break;
        &#125;
    &#125;
    return tab;
&#125;
</code></pre>
<h2 id="2-2-tabAt"><a href="#2-2-tabAt" class="headerlink" title="2.2 tabAt"></a>2.2 tabAt</h2><pre><code class="java">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;
    return (Node&lt;K,V&gt;)U.getObjectAcquire(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);
&#125;

public final Object getObjectAcquire(Object o, long offset) &#123;
    return getObjectVolatile(o, offset);
&#125;
</code></pre>
<p>看名字就很容易能看懂是干嘛的了，因为我们不能给数组的某个元素加<code>volatile</code>，所以只能用这种方式保证可见性。</p>
<p>这里的ASHIFT和ABASE可以在源码的最后的静态代码块处看到，这里我将其提了出来：</p>
<pre><code class="java">static final Unsafe U = createUnsafe();

public static Unsafe createUnsafe() &#123;
    try &#123;
        Class&lt;?&gt; unsafeClass = Class.forName(&quot;sun.misc.Unsafe&quot;);
        Field field = unsafeClass.getDeclaredField(&quot;theUnsafe&quot;);
        field.setAccessible(true);
        return (Unsafe) field.get(null);
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
    return null;
&#125;

static class Node &#123;&#125;

public static void main(String[] args) &#123;
    int[] arr = new int[10];
    int scale = U.arrayIndexScale(Node[].class);
    int ABASE = U.arrayBaseOffset(Node[].class);
    int ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);
    System.out.println(&quot;ABASE = &quot; + ABASE + &quot;, ASHIFT = &quot; + ASHIFT + &quot;, scale = &quot; + scale);

    scale = U.arrayIndexScale(long[].class);
    ABASE = U.arrayBaseOffset(long[].class);
    ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);
    System.out.println(&quot;ABASE = &quot; + ABASE + &quot;, ASHIFT = &quot; + ASHIFT + &quot;, scale = &quot; + scale);
&#125;
</code></pre>
<p>输出：</p>
<pre><code class="text">ABASE = 16, ASHIFT = 2, scale = 4
ABASE = 16, ASHIFT = 3, scale = 8
</code></pre>
<p>这里的scale很明显，代表数组每个元素的占用大小。</p>
<p>ABASE则是元素在数组里的偏移值，一般大小为：<strong>对象头(8字节) + 类型指针(默认4字节，关闭指针压缩后为8字节) + 数组长度(4字节)  &#x3D; 16</strong>，如果你不清楚我在说什么，可以去看一下我的这篇博客：<a target="_blank" rel="noopener" href="https://www.notion.so/f3486133d4f64c738ae857df740bee95">对象在内存中的存储布局 (notion.so)</a>。</p>
<p>ASHIFT则是表示当前元素占用大小二进制的1右边有多少个0，在<code>ConcurrentHashMap</code>初始化时，如果scale不是2的幂则会报错。</p>
<p>那么在取值的时候是什么意思呢？</p>
<p>其实这里很像C的指针了，ABASE代表基础偏移值，而<code>i &lt;&lt; ASHIFT</code>则每个元素的位置：</p>
<ul>
<li><p>比如<code>i</code>为0，<code>i &lt;&lt; ASHIFT = 0</code>，代表这个元素在<code>对象在堆中的地址 + ABASE</code></p>
</li>
<li><p>比如<code>i</code>为1，<code>i &lt;&lt; ASHIFT = 4</code>，代表这个元素在<code>对象在堆中的地址 + ABASE + 4</code></p>
</li>
</ul>
<h2 id="2-2-putVal"><a href="#2-2-putVal" class="headerlink" title="2.2 putVal"></a>2.2 putVal</h2><p><code>put</code>内部其实就是调用了<code>putVal</code>：</p>
<pre><code class="java">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;
    if (key == null || value == null) throw new NullPointerException();
    // 在这里将key的哈希高16位和低16位进行异或后得到新的哈希
    int hash = spread(key.hashCode());
    int binCount = 0;
    // 看到这层死循环就应该感觉到会有CAS出现
    for (Node&lt;K,V&gt;[] tab = table;;) &#123;
        Node&lt;K,V&gt; f; int n, i, fh; K fk; V fv;
        if (tab == null || (n = tab.length) == 0)
            // 初始化表
            tab = initTable();
        // 这里取哈希索引和HashMap一样
        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;
            // 这个位置没有元素，则尝试CAS放进去
            if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value)))
                break;                   // no lock when adding to empty bin
        &#125;
        // 这里后面再讲
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        // 在这里判断是否需要替换掉原节点
        else if (onlyIfAbsent // check first node without acquiring lock
                 &amp;&amp; fh == hash
                 &amp;&amp; ((fk = f.key) == key || (fk != null &amp;&amp; key.equals(fk)))
                 &amp;&amp; (fv = f.val) != null)
            return fv;
        else &#123;
            V oldVal = null;
            // 锁住当前节点
            synchronized (f) &#123;
                // 确保这个没有被修改
                if (tabAt(tab, i) == f) &#123;
                    // 这里要知道，如果节点是红黑树，哈希值为-2
                    if (fh &gt;= 0) &#123;
                        // 这个值代表链表的大小
                        binCount = 1;
                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;
                            K ek;
                            // 这里同样也是在尝试进行替换：判断hash和key是否相等
                            if (e.hash == hash &amp;&amp;
                                ((ek = e.key) == key ||
                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            &#125;
                            // 这里检查是否遍历到链表尾部，如果到尾部了则直接插入
                            Node&lt;K,V&gt; pred = e;
                            if ((e = e.next) == null) &#123;
                                pred.next = new Node&lt;K,V&gt;(hash, key, value);
                                break;
                            &#125;
                        &#125;
                    &#125;
                    // 如果是红黑树
                    else if (f instanceof TreeBin) &#123;
                        Node&lt;K,V&gt; p;
                        binCount = 2;
                        // 在红黑树里进行查找
                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                              value)) != null) &#123;
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        &#125;
                    &#125;
                    // 这个后面讲
                    else if (f instanceof ReservationNode)
                        throw new IllegalStateException(&quot;Recursive update&quot;);
                &#125;
            &#125;
            // 这里判断是否需要将链表树化
            if (binCount != 0) &#123;
                if (binCount &gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            &#125;
        &#125;
    &#125;
    // 进行统计，同时在这里判断是否需要扩容
    addCount(1L, binCount);
    return null;
&#125;
</code></pre>
<h2 id="2-3-addCount"><a href="#2-3-addCount" class="headerlink" title="2.3 addCount"></a>2.3 addCount</h2><p>这个方法比较复杂，先讲一些其它的小方法。</p>
<h3 id="2-3-1-resizeStamp"><a href="#2-3-1-resizeStamp" class="headerlink" title="2.3.1 resizeStamp"></a>2.3.1 resizeStamp</h3><pre><code class="java">static final int resizeStamp(int n) &#123;
    return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));
&#125;
</code></pre>
<p>这个方法主要是获取n最高位前面有几个0，然后和后面的值相与。RESIZE_STAMP_BITS为常量：16</p>
<p>那么右边整体就是个常量：(1 &lt;&lt; 15) 即1的右边15个0。</p>
<p>那么这个方法有什么用呢？其实这里是用作来生成一个扩容标记的，相当于一个版本号。</p>
<p>至于这么玩有什么用，正常看源码到这里是不知道的，我们先接着往后看。</p>
<h3 id="2-3-2-transfer"><a href="#2-3-2-transfer" class="headerlink" title="2.3.2 transfer"></a>2.3.2 transfer</h3><blockquote>
<p>Moves and&#x2F;or copies the nodes in each bin to new table. See above for explanation.</p>
</blockquote>
<p>这个方法大致就是将节点从旧哈希表复制或者移动到新的哈希表中，方法很长。</p>
<p>源码里又出现了两个新的类变量：</p>
<ul>
<li><code>nextTable</code>：表示新的哈希表，仅在扩容时非空。</li>
<li><code>transferIndex</code>：The next table index (plus one) to split while resizing. 这里不是很好理解，就不翻译了，看源码就能懂。</li>
</ul>
<p>同时这里用到了一个新的节点：<code>ForwardingNode</code>，这个节点继承了基础的<code>Node</code>节点，<font color=red>但是其hash值永远为MOVED，即为<code>-1</code></font>。同时，内部还保存了新的哈希表<code>nextTable</code>。根据文档翻译，这个节点是用作一个头结点，作为新哈希表的表头（A node inserted at head of bins during transfer operations.）。</p>
<p><code>transfer</code>是并发扩容的实现，对于每个线程，<font color=red>每次会分配一块固定长度大小的区域</font>来让线程对tab进行重新hash，这个区域的大小与CPU核心数成反比，但最小为16。</p>
<pre><code class="java">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;
    int n = tab.length, stride;
    // 将n/8/CPU核心数当做区域大小，最小值为16
    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)
        stride = MIN_TRANSFER_STRIDE; // subdivide range
    // nextTab为空，表示当前线程是第一个进行扩容的线程
    if (nextTab == null) &#123;            // initiating
        try &#123;
            @SuppressWarnings(&quot;unchecked&quot;)
            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];
            nextTab = nt;
        &#125; catch (Throwable ex) &#123;      // try to cope with OOME
            // OOM的fallback
            sizeCtl = Integer.MAX_VALUE;
            return;
        &#125;
        nextTable = nextTab;
        transferIndex = n;
    &#125;
    int nextn = nextTab.length;
    // 用于占位。当别的线程发现这个槽位中是 fwd 类型的节点，则跳过这个节点。
    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);
    boolean advance = true;
    boolean finishing = false; // to ensure sweep before committing nextTab
    for (int i = 0, bound = 0;;) &#123;
        Node&lt;K,V&gt; f; int fh;
        while (advance) &#123;
            // 1. 因为advance一开始肯定为true，所以进入这个循环
            int nextIndex, nextBound;
            // --i相当于从大到小去分配区域
            if (--i &gt;= bound || finishing)
                advance = false;
            // 获取当前已经分配到的索引
            else if ((nextIndex = transferIndex) &lt;= 0) &#123;
                // 小于0表示已经扩容完了
                i = -1;
                advance = false;
            &#125;
            // 尝试接下这块区域
            else if (U.compareAndSetInt
                     (this, TRANSFERINDEX, nextIndex,
                      nextBound = (nextIndex &gt; stride ?
                                   nextIndex - stride : 0))) &#123;
                // 到这里，说明当前线程已经接下了[nextBound, nextIndex - 1]这块区域重新分配的任务
                bound = nextBound;
                i = nextIndex - 1;
                advance = false;
            &#125;
        &#125;
        // i小于0，说明线程没拿到任务
        // 至于后面那俩，我们仔细观察即可发现：这两个发生的条件是某一个线程进行扩容时，其它线程已经扩容完了
        // 并且又开启了新一轮的扩容
        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;
            int sc;
            // 判断扩容已经完成
            if (finishing) &#123;
                nextTable = null;
                table = nextTab;
                // 这里重新分配扩容阈值，负载因子为0.75
                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);
                return;
            &#125;
            // 将sizeCtl - 1，在开头我们已经说了，sizeCtl低16位保存当前正在进行扩容的线程数量
            if (U.compareAndSetInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;
                // 这里判断是否只有一个线程在扩容
                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)
                    // 只有一个线程扩容，且没有接到任务，说明扩容完成了
                    return;
                // 还有别的线程在扩容，给个标记后再重新检查一遍。。
                finishing = advance = true;
                i = n; // recheck before commit
            &#125;
        &#125;
        // 如果任务区间最后一个为空
        else if ((f = tabAt(tab, i)) == null)
            // 尝试CAS将其赋值为占位节点
            advance = casTabAt(tab, i, null, fwd);
        // 如果为true，表示有其它人跟自己一样分配到了一样的任务，需要重新分配任务.
        // 注意这里有--i，不用担心和上一次一样取到一样的hash
        else if ((fh = f.hash) == MOVED)
            advance = true; // already processed
        else &#123;
            // 锁住尾节点
            synchronized (f) &#123;
                // 再检查一遍
                if (tabAt(tab, i) == f) &#123;
                    Node&lt;K,V&gt; ln, hn;
                    if (fh &gt;= 0) &#123;
                        // 链表转移. 这里貌似用的是尾插法.
                        int runBit = fh &amp; n;
                        Node&lt;K,V&gt; lastRun = f;
                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;
                            int b = p.hash &amp; n;
                            if (b != runBit) &#123;
                                runBit = b;
                                lastRun = p;
                            &#125;
                        &#125;
                        if (runBit == 0) &#123;
                            ln = lastRun;
                            hn = null;
                        &#125;
                        else &#123;
                            hn = lastRun;
                            ln = null;
                        &#125;
                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;
                            int ph = p.hash; K pk = p.key; V pv = p.val;
                            if ((ph &amp; n) == 0)
                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);
                            else
                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);
                        &#125;
                        setTabAt(nextTab, i, ln);
                        setTabAt(nextTab, i + n, hn);
                        setTabAt(tab, i, fwd);
                        advance = true;
                    &#125;
                    else if (f instanceof TreeBin) &#123;
                        // 树节点转移
                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;
                        TreeNode&lt;K,V&gt; lo = null, loTail = null;
                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;
                        int lc = 0, hc = 0;
                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;
                            int h = e.hash;
                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;
                                (h, e.key, e.val, null, null);
                            if ((h &amp; n) == 0) &#123;
                                if ((p.prev = loTail) == null)
                                    lo = p;
                                else
                                    loTail.next = p;
                                loTail = p;
                                ++lc;
                            &#125;
                            else &#123;
                                if ((p.prev = hiTail) == null)
                                    hi = p;
                                else
                                    hiTail.next = p;
                                hiTail = p;
                                ++hc;
                            &#125;
                        &#125;
                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :
                        (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;
                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :
                        (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;
                        setTabAt(nextTab, i, ln);
                        setTabAt(nextTab, i + n, hn);
                        setTabAt(tab, i, fwd);
                        advance = true;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="2-3-3-总结"><a href="#2-3-3-总结" class="headerlink" title="2.3.3 总结"></a>2.3.3 总结</h3><p>了解过上面两个方法后，再来看addCount就清晰多了</p>
<pre><code class="java">private final void addCount(long x, int check) &#123;
    CounterCell[] cs; long b, s;
    if ((cs = counterCells) != null ||
        // 这里去cas设置总节点数量
        !U.compareAndSetLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123;
        // 这里就使用了类似LongAdder和Striped64的设计，将自增分散到多个格子里
        CounterCell c; long v; int m;
        boolean uncontended = true;
        if (cs == null || (m = cs.length - 1) &lt; 0 ||
            (c = cs[ThreadLocalRandom.getProbe() &amp; m]) == null ||
            !(uncontended =
              U.compareAndSetLong(c, CELLVALUE, v = c.value, v + x))) &#123;
            fullAddCount(x, uncontended);
            return;
        &#125;
        if (check &lt;= 1)
            return;
        // 在这里重新获取总节点数量
        s = sumCount();
    &#125;
    // 这s和b已经赋过值了
    // 这里主要判断是否需要当前线程去扩容或协助扩容
    if (check &gt;= 0) &#123;
        Node&lt;K,V&gt;[] tab, nt; int n, sc;
        // 又是循环，CAS的小曲
        // 这里主要判断容量是否大于等于sizeCtl，然后进行扩容
        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;
               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;
            // 后面讲
            int rs = resizeStamp(n);
            // 判断是否有其它线程正在修改
            if (sc &lt; 0) &#123;
                // 如果有，判断当前容量是否已经发生改变
                // sc == rs + 1是用来判断当前是否没有线程在进行扩容
                // 后面的都是用来判断扩容是否已经完成了，不需要当前线程进行协助扩容
                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                    transferIndex &lt;= 0)
                    break;
                // 协助进行扩容，将sizeCtl + 1，表示多了一个线程在进行扩容
                if (U.compareAndSetInt(this, SIZECTL, sc, sc + 1))
                    transfer(tab, nt);
            &#125;
            // 这里CAS修改sizeCtl为(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)，表示当前线程是第一个发起扩容的
            else if (U.compareAndSetInt(this, SIZECTL, sc,
                                        (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))
                transfer(tab, null);
            s = sumCount();
        &#125;
    &#125;
&#125;
</code></pre>
<p>关于<code>rs &lt;&lt; RESIZE_STAMP_SHIFT</code>可能不好理解，这里我们举个例子：</p>
<pre><code class="java">int n = 16;
int i = Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; 15);
//        System.out.println(Integer.toBinaryString());
System.out.println(Integer.toBinaryString(i));
System.out.println(Integer.toBinaryString(i &lt;&lt; 16));
</code></pre>
<p>输出：</p>
<pre><code class="text">1000000000011011
10000000000110110000000000000000
</code></pre>
<p>我们在开头也说过了，ctl高16位代表一个版本号，第16位然后再减一代表当前正在扩容的线程数，所有这里就代表当前有一个线程正在进行扩容。</p>
<h2 id="2-4-sumCount"><a href="#2-4-sumCount" class="headerlink" title="2.4 sumCount"></a>2.4 sumCount</h2><p>这里就是类似于LongAdder一样，获取元素总数量，size方法也是调用的这个：</p>
<pre><code class="java">final long sumCount() &#123;
    CounterCell[] cs = counterCells;
    long sum = baseCount;
    if (cs != null) &#123;
        for (CounterCell c : cs)
            if (c != null)
                sum += c.value;
    &#125;
    return sum;
&#125;

public int size() &#123;
    long n = sumCount();
    return ((n &lt; 0L) ? 0 :
            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
            (int)n);
&#125;
</code></pre>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 IceOfSummerの博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;<a target="_blank" rel="noopener" href="https://github.com/IceOfSummer">IceOfSummer</a>
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/IceOfSummer/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        
<script
    src="https://giscus.app/client.js"
    data-repo="IceOfSummer/iceofsummer.github.io"
    data-repo-id="R_kgDOJFU7OQ"
    data-category="Announcements"
    data-category-id="DIC_kwDOJFU7Oc4CUyC7"
    data-mapping="title"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin
    async
></script>





        
    </body>
</html>
