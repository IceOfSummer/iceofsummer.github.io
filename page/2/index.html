
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <title>IceOfSummerの博客</title>
        <meta name="author" content="IceOfSummer">
        <meta name="description" content="用来用去还是自己搭的博客靠谱">
        <meta name="keywords" content="">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <script src="https://cdn.staticfile.org/vue/3.2.45/vue.global.prod.min.js"></script>
        <script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
        <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css">
        <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.2.1/css/all.min.css">
        
        <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
        
        
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
    <!-- hexo injector head_end start --><script>window.addEventListener("load",()=>{const e="$toTopHeight";let t=0;const n="lazy";let o=[...document.getElementsByTagName("img")];console.log(`图片懒加载: 一共找到了${o.length}张图片`),setTimeout(()=>{t++,l()},500);const i=()=>{l()};function l(){if(0===o.length)return console.log("所有图片均已加载"),void window.removeEventListener("scroll",i);const e=[];for(let t=0,n=o.length;t<n;++t){const n=o[t];s(n)?(console.log("已经加载图片: ",n),r(n)):e.push(n)}o=e}function r(e){const t=e.getAttribute(n);t&&(e.setAttribute("src",t),e.removeAttribute(n))}function s(n){if(!n)return!1;const o=function(n){const o=n[e];if(o&&o.version===t)return n[e].value;let i=n,l=0;do{l+=i.offsetTop,i=i.offsetParent}while(i);return n[e]={value:l,version:t},l}(n);return document.documentElement.scrollTop+document.documentElement.clientHeight>=o}window.addEventListener("scroll",i),window.addEventListener("resize",()=>{t++})});</script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="loading" style="height: 100vh; width: 100vw; left: 0; top: 0; position: fixed; display: flex; z-index: 2147483647; background: #fff; transition: opacity 0.3s ease-out; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; pointer-events: none">
    <div style="width: 50vmin; height: 50vmin; margin: auto; padding: 50px; border-radius: 50%; display: flex; border: solid 10px #a3ddfb">
        <div style="margin: auto; text-align: center">
            <h2>LOADING</h2>
            <p>加载过慢请开启缓存，浏览器默认开启</p>
            <img src="/images/loading.gif" style="height: 50px; border-radius: 0">
        </div>
    </div>
</div>

        <div id="layout">
            <transition name="into">
            <div id="main" v-show="showpage" style="display: -not-none">
                <nav id="menu">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>ICEOFSUMMERの博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
    </div>
    <div :class="&quot;phone-menu &quot; + menushow" id="phone-menu">
        <div class="curtain" @click="menushow = !menushow" v-show="menushow"></div>
        <div class="title" @click="menushow = !menushow">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ICEOFSUMMERの博客</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menushow">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

                <div id="home-head">
    <div id="home-background"></div>
    
    <div id="home-info" @click="homeclick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>IceOfSummerの博客</h1>
                <h3>一时起兴搭建的博客</h3>
                <h5>用来用去还是自己搭的博客靠谱</h5>
            </div>
        </span>
    </div>
    
</div>
<div id="home-posts-wrap" class="">
    <div id="home-posts">
        <div id="posts">
            

<div class="post">
    <a href="/2023/03/22/computer-network/">
        <h2 class="post-title">计网常用知识总结</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/22
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="1-网际协议IP"><a href="#1-网际协议IP" class="headerlink" title="1. 网际协议IP"></a>1. 网际协议IP</h1><h2 id="1-1-IPv4"><a href="#1-1-IPv4" class="headerlink" title="1.1 IPv4"></a>1.1 IPv4</h2><p><img lazy="https://xds.asia/public/post/2023-2-4-7b4a02b9-5e93-4d3e-80e8-ec67eda52d2a.webp" alt="IP报文格式"></p>
<ul>
<li>版本：IPv4为4，IPv6即为6</li>
<li>首部长度：<font color=red>单位为4字节</font>，因此头部最长为15个4字节，即60字节</li>
<li>区分服务（旧版叫服务类型）：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/160937314">QoS分类和标记 - 知乎 (zhihu.com)</a></li>
<li>总长度：总长度包括首部和数据的长度。</li>
<li>标识：用于路由器分片重组。同一个分片的标志值相同，不同的分片的标识值不同。</li>
<li>标志：占3位，但只两位可以使用<ul>
<li>最低位(可以理解为最右边)：记为MF(More Fragment)。MF &#x3D; 1标识后面<strong>还有分片</strong>。</li>
<li>中间位：记为DF(Don’t Fragment)，意为<strong>不能分片</strong>，只有当DF &#x3D; 0时才允许分片。</li>
</ul>
</li>
<li>片偏移：较长的分组在分片后，某片在原分组中的相对位置，单位是8字节。<ul>
<li>例如有一个数据有3800字节，被分为了1400字节、1400字节、1000字节(忽略了首部)，则它们的片偏移分别为：<code>0/8 = 0</code>，<code>1400 / 8 = 175</code>，<code>2800 / 8 = 350</code></li>
</ul>
</li>
<li>生存时间：一般称为TTL(Time To Live)，标明数据报在网络中的<strong>寿命</strong>。最初的设计是以<font color=red>秒</font>作为TTL的单位，每经过一个路由器就减掉响应的时间，到零时则会被丢弃。然而随着技术的进步，路由器处理数据报所需的时间不断在缩短，一般都远远小于1秒，后来就把TTL字段的功能改为“跳数限制”，即每经过一个路由器，就将该值减一，到零时就删除掉，最大值为255</li>
<li>协议：见下表</li>
</ul>
<table>
<thead>
<tr>
<th>协议名</th>
<th align="center">ICMP</th>
<th align="center">IGMP</th>
<th align="center">IP</th>
<th align="center">TCP</th>
<th align="center">EGP</th>
<th align="center">IGP</th>
<th align="center">UDP</th>
<th align="center">IPv6</th>
<th align="center">ESP</th>
<th align="center">ICMP-IPv6</th>
</tr>
</thead>
<tbody><tr>
<td>字段值</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center"><font color=red>6</font></td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center"><font color=red>17</font></td>
<td align="center">41</td>
<td align="center">50</td>
<td align="center">58</td>
</tr>
</tbody></table>
<ul>
<li>首部校验和：这个字段只检验数据报的首部，但不包括数据部分。具体运算方式是把首部按16字节划分，然后按照反码算术相加得到。</li>
<li>源地址：发送IP数据报主机的IP地址</li>
<li>目的地址：占32位。接收IP数据报主机的IP地址</li>
<li>选项：由于选项很难背用到，而且也会增加路由器的开销，因此在IPv6中，IP数据报首部长度被改为固定值了</li>
</ul>
<h2 id="1-2-IPv6"><a href="#1-2-IPv6" class="headerlink" title="1.2 IPv6"></a>1.2 IPv6</h2><p><img lazy="https://xds.asia/public/post/2023-2-4-48265f3c-796f-4a2e-a261-b4f4ed0cd38f.webp" alt="IPv6"></p>
<ul>
<li><p>版本：IPv6肯定就是6了</p>
</li>
<li><p>通信量类(Traffic Class)：这是为了区分不同的IPv6数据报的类别或优先级，和IPv4的区分服务字段的作用相似。</p>
</li>
<li><p>流标号(Flow Label)：IPv6的一个新的机制是支持资源预分配，并且允许路由器把每个数据报与一个给定的资源分配相联系。</p>
</li>
<li><p>有效荷载长度：它指明IPv6数据报除基本首部以为的字节数（所有扩展首部都算在有效荷载之内）。</p>
</li>
<li><p>下一个首部：它相当于IPv4的协议字段或可选字段。</p>
</li>
<li><p>跳数限制：用来防止数据报在网络中无期限的存在。</p>
</li>
</ul>
<h1 id="2-TCP"><a href="#2-TCP" class="headerlink" title="2. TCP"></a>2. TCP</h1><h2 id="2-1-三次握手"><a href="#2-1-三次握手" class="headerlink" title="2.1 三次握手"></a>2.1 三次握手</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/430799766">深入浅出TCP三次握手 （多图详解） - 知乎 (zhihu.com)</a></p>
<p>主要是要记住客户端和服务端的状态：</p>
<ul>
<li>客户端：CLOSED -&gt; SYN-SENT -&gt; ESTABLISHED</li>
<li>服务端：CLOSED -&gt; SYN-RCVD -&gt; ESTABLISHED</li>
</ul>
<p>之后在每次通信时，下次消息的<code>seq</code>为对方上次消息的<code>ack</code>，下次消息的<code>ack</code>为对方上次消息的<code>seq + 总数据长度</code>(同一个<code>seq</code>可能会有多个消息)</p>
<p><font color=red>在握手时，虽然数据长度为0，在理解时需要将其”当做”长度为1。</font></p>
<h2 id="2-2-四次挥手"><a href="#2-2-四次挥手" class="headerlink" title="2.2 四次挥手"></a>2.2 四次挥手</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LOOKTOMMER/article/details/121307137">TCP四次挥手详解_‍oOoOoOooOO的博客-CSDN博客</a></p>
<p>客户端和服务端的状态：</p>
<ul>
<li>客户端(主动关闭的那一方)：ESTABLISHED -&gt; FIN_WAIT -&gt; TIME_WAIT(等待2ms) -&gt; CLOSE</li>
<li>服务端(响应关闭的那一方)：ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK -&gt; CLOSE</li>
</ul>
<p>这里在主动关闭的那一方需要等待2ms，原因如下：</p>
<ul>
<li><p>首先占用该端口，因为IP报文在网络中的生存时间是有限的，让旧的报文全部在网络中被丢弃</p>
</li>
<li><p>若主动关闭的那一方的ACK没有被服务端收到，此时服务端再次返回一个FIN报文，会被客户端错误的以为是一个错误报文而导致状态重置(发送RST报文)</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/99943313">TCP的TIME_WAIT状态 - 知乎 (zhihu.com)</a></p>
<h2 id="2-3-TCP报文格式"><a href="#2-3-TCP报文格式" class="headerlink" title="2.3 TCP报文格式"></a>2.3 TCP报文格式</h2><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6441.html">TCP报文格式解析 (biancheng.net)</a></p>
<p>其中可能比较难记的就是8个标志位的前两个了，其实只需要记住全称就不容易忘了：</p>
<ul>
<li>CWR：Congestion Window Reduce</li>
<li>ECE：ECN Echo，全称Explicit Congestin Notification Echo</li>
</ul>
<p>里面还有个校验和，这里需要知道是怎么算的。在计算机网络第八版P218中介绍了UDP的检验和计算：</p>
<ul>
<li>首先在数据报前添加一个伪首部</li>
<li>将校验和的位置置零</li>
<li>以16位2个字节为单位，如果由于数据的长度导致无法满足该条件，则在数据部分后补零即可。之后将所有数据相加，如果溢出，则添加到低位(二进制反码运算求和)</li>
<li>将结果取反添加到校验和的位置</li>
</ul>
<p>在验证时同样使用上面的方法，但不用把校验位置零，若计算结果最终为全1，则表示数据无误</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42560250/article/details/113526217">TCP&#x2F;UDP伪头部详解_tcp 伪头部_M、k的博客-CSDN博客</a></p>
<p>需要注意的是IP报文的校验不包含数据。</p>
<h1 id="3-路由器和交换机"><a href="#3-路由器和交换机" class="headerlink" title="3. 路由器和交换机"></a>3. 路由器和交换机</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/jiPMUk6zUdOY6eKxAjNDbQ">如果让你来设计网络 (qq.com)</a></p>
<p>交换机是工作在数据链路层的，它根据每台设备的MAC地址来转发数据。</p>
<p>而路由器是工作在网络层的，它负责IP报文的转发。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2023/03/22/computer-network/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/03/19/interview2/">
        <h2 class="post-title">面试题记录2</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/19
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <ul>
<li><a href="/2023/03/14/interview/">第一期</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/uRUsKF/">八股文｜后端｜MySQL｜答案 - 力扣（LeetCode）</a></p>
<h1 id="1-简单说一下InnoDB事务实现原理"><a href="#1-简单说一下InnoDB事务实现原理" class="headerlink" title="1. 简单说一下InnoDB事务实现原理"></a>1. 简单说一下InnoDB事务实现原理</h1><p>事务ACID：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>别名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Atomicity</strong></td>
<td>原子性</td>
<td>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生</td>
</tr>
<tr>
<td><strong>Consistency</strong></td>
<td>一致性</td>
<td>事务前后数据的完整性必须保持一致</td>
</tr>
<tr>
<td><strong>Isolation</strong></td>
<td>隔离性</td>
<td>事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离</td>
</tr>
<tr>
<td><strong>Durability</strong></td>
<td>持久性</td>
<td>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/48327345">一文了解InnoDB事务实现原理 - 知乎 (zhihu.com)</a></p>
<p>上面那个比较深入，下面这个比较好理解一些：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7012937835967692808">图解InnoDB事务实现原理｜Redo Log&amp;Undo Log - 掘金 (juejin.cn)</a></p>
<h1 id="2-Redis的内存淘汰算法"><a href="#2-Redis的内存淘汰算法" class="headerlink" title="2. Redis的内存淘汰算法"></a>2. Redis的内存淘汰算法</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/crazymakercircle/article/details/115360829">Redis 内存淘汰策略 （史上最全）_redis内存淘汰策略_40岁资深老架构师尼恩的博客-CSDN博客</a></p>
<h1 id="3-Redis主从复制"><a href="#3-Redis主从复制" class="headerlink" title="3. Redis主从复制"></a>3. Redis主从复制</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bilson99/article/details/118732296">Redis（主从复制、哨兵模式、集群）的讲解_redis集哨兵模式哪个节点负责读取数据_五条悟的小迷妹的博客-CSDN博客</a></p>
<h1 id="4-Redis的持久化方式"><a href="#4-Redis的持久化方式" class="headerlink" title="4. Redis的持久化方式"></a>4. Redis的持久化方式</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Violet_201903027/article/details/100145168">Redis有哪几种持久化方式？优缺点是什么_Listener_code的博客-CSDN博客</a></p>
<h1 id="5-Redis常见的性能问题和解决方案"><a href="#5-Redis常见的性能问题和解决方案" class="headerlink" title="5. Redis常见的性能问题和解决方案"></a>5. Redis常见的性能问题和解决方案</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7207406497541455929">Redis 常见性能问题和解决方案 - 掘金 (juejin.cn)</a></p>
<h1 id="6-MySql的三大日志是哪些"><a href="#6-MySql的三大日志是哪些" class="headerlink" title="6. MySql的三大日志是哪些"></a>6. MySql的三大日志是哪些</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7090530790156533773">MySQL三大日志(binlog,redolog,undolog)详解 - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903842505555981">聊聊MVCC和Next-key Locks - 掘金 (juejin.cn)</a></p>
<h1 id="7-MySql当前读和快照度"><a href="#7-MySql当前读和快照度" class="headerlink" title="7. MySql当前读和快照度"></a>7. MySql当前读和快照度</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7055073479866974238">mysql快照读原理实现 - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/166152616">MySQL 的可重复读到底是怎么实现的？图解 ReadView 机制 - 知乎 (zhihu.com)</a></p>
<p>这里其实有个问题，如果我只是单独的一条查询语句，没有开启事务，那么怎么去快照读呢？</p>
<p>这个我自己查了一下，众所周知，MySql里有一个autocommit属性，对于单条SQL，这个值一定是true，那么是不是说明我们每条SQL都会被认作是一个事务呢？</p>
<p>然后我在官方文档里查了一下：</p>
<p><img lazy="https://xds.asia/public/interview/2023-2-0-bd1f976d-ac67-49a3-979b-1b9cd4fa2c6d.webp" alt="每条SQL都是一个单独的事务"></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-autocommit-commit-rollback.html">MySQL :: MySQL 5.7 Reference Manual :: 14.7.2.2 autocommit, Commit, and Rollback</a></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-autocommit-commit-rollback.html">MySQL :: MySQL 8.0 Reference Manual :: 15.7.2.2 autocommit, Commit, and Rollback</a></p>
<p>不管是8.0还是5.7，都是这样写的，那么就可以说的通了。每次执行单条SQL都会拿到一个事务id，然后再去进行快照读。</p>
<p>那么什么是当前读呢，使用下面的sql语句就是当前读：</p>
<pre><code class="sql"># 加共享锁
SELECT ... LOCK IN SHARE MODE 
# 加排它锁
SELECT ... FROM UPDATE
</code></pre>
<p>这两条语句的原理就是给对应的行加上<font color=red>共享锁(读锁)或排它锁(写锁)</font>，当有事务进行增删改时也会加排它锁，对于共享锁，允许多个事务持有(即允许多读)，对于排它锁，则只允许一个事务持有(即只能一个人写，且除了自己其它人都不能读)。</p>
<p>在排它锁和共享锁下读的的数据就是当前读，这份数据永远是最新的(此时若有其它事务想要修改相关的行，都会被阻塞)。其它状况则就是快照读了，通过MVCC创建ReadView进行数据的读取。</p>
<h1 id="8-MySql的MVCC"><a href="#8-MySql的MVCC" class="headerlink" title="8. MySql的MVCC"></a>8. MySql的MVCC</h1><p>MVCC(Multiversion Concurrency Control)多版本并发控制。</p>
<p>首先在在MVCC下，每个表都会多出几个隐藏的列，分别为隐藏主键(row_id)、事务id(trx_id)、回滚指针(roll_pointer)。</p>
<p>MVCC还有两个重要的组成：undo log(回滚日志)、ReadView。</p>
<p>更详细的就不说了，因为上面的链接里面都有，主要是下面这四个关系：</p>
<p>（1）当【版本链中记录的 trx_id 等于当前事务id（trx_id &#x3D; creator_trx_id）】时，说明版本链中的这个版本是当前事务修改的，所以该快照记录对当前事务可见。</p>
<p>（2）当【版本链中记录的 trx_id 小于活跃事务的最小id（trx_id &lt; min_trx_id）】时，说明版本链中的这条记录已经提交了，所以该快照记录对当前事务可见。</p>
<p>（3）当【版本链中记录的 trx_id 大于下一个要分配的事务id（trx_id &gt; max_trx_id）】时，该快照记录对当前事务不可见。</p>
<p>（4）当【版本链中记录的 trx_id 大于等于最小活跃事务id】且【版本链中记录的trx_id小于下一个要分配的事务id】（min_trx_id&lt;&#x3D; trx_id &lt; max_trx_id）时，如果版本链中记录的 trx_id 在活跃事务id列表 m_ids 中，说明生成 ReadView 时，修改记录的事务还没提交，所以该快照记录对当前事务不可见；否则该快照记录对当前事务可见。</p>
<h2 id="8-1-RepeatableRead是怎么实现的"><a href="#8-1-RepeatableRead是怎么实现的" class="headerlink" title="8.1 RepeatableRead是怎么实现的"></a>8.1 RepeatableRead是怎么实现的</h2><p>我们都知道，RepeatableRead相比ReadCommited能够避免不可重复读的问题(实际也能够避免幻读，是通过加间隙锁实现的)。</p>
<p>首先我们来看ReadCommitted，使用mysql执行如下指令(假如我们叫它事务A)</p>
<pre><code class="sql">set session transaction isolation level read committed;
begin;
update test set xid = 2 where id = 1;
# 等一会再提交
commit;
</code></pre>
<p>然后再开一个mysql执行如下指令(假如我们叫它事务B)：</p>
<pre><code class="sql">set session transaction isolation level read committed;
begin;
select * from test where id = 1;
# 提交上面那个指令后再执行下面这条
select * from test where id = 1;
</code></pre>
<p>这里就不放图了，大家都知道第二次读取会不一样。</p>
<p>这回我们再将隔离级别设置为RepeatableRead，并同样执行上面的指令。</p>
<p>这次执行后，<font color=red>发现两次查询的结果都是一样的</font>，而且在事务A执行更新后且没有提交时，B再去读，<font color=red>并没有发生阻塞，因为在修改数据的时候会加排它锁，在读的时候要么是当前读要么是快照读，</font>如果是当前读，那么读操作会堵塞，说明在B这里是快照读，是创建了ReadView的，通过ReadView有效地避免了不可重复读。</p>
<p>我们再用同样的方式去验证ReadCommited级别的读，发现同样是快照读，那么凭什么RepeatableRead不会读到新值，而ReadCommited会呢？</p>
<p>这里我画了一个流程图方便理解：</p>
<p><img lazy="https://xds.asia/public/interview/2023-2-1-7f41e3a0-6d4e-42e8-b44e-d85eecdbd465.webp" alt="流程图"></p>
<p><del>图画的可能不太好，不过应该能看懂</del></p>
<p>网上大部分人讲的都是以ReadCommited级别为例子的，即m_ids里的事务提交后可读，但其实在RepeatableRead隔离级别下是读不了的，只能走undo_log进行回滚。</p>
<hr>
<p><font color=red>这里可能有点错误，在ReadCommited下可以读已经提交的事务，所以如果trx_id大于等于mid_id，只需要判断对应的事务是否已经提交(或者trx_id指向自己)就能读</font></p>
<h1 id="9-RepeatableRead真的不能避免幻读吗"><a href="#9-RepeatableRead真的不能避免幻读吗" class="headerlink" title="9. RepeatableRead真的不能避免幻读吗?"></a>9. RepeatableRead真的不能避免幻读吗?</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_71777195/article/details/126968432">美团三面：一直追问我， MySQL 幻读被彻底解决了吗？_肥肥技术宅的博客-CSDN博客</a></p>
<h1 id="10-为什么bin-log不能用作崩溃后的恢复"><a href="#10-为什么bin-log不能用作崩溃后的恢复" class="headerlink" title="10. 为什么bin_log不能用作崩溃后的恢复"></a>10. 为什么bin_log不能用作崩溃后的恢复</h1><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/463438061">mysql 为什么不能用binlog来做数据恢复？ - 知乎 (zhihu.com)</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2023/03/19/interview2/" class="go-post">阅读全文</a>
</div>


            <div class="page-current">
    <div class="prev">
        
        <a class="page-num" href="/">
            <i class="fa-solid fa-caret-left fa-fw"></i>
        </a>
        
    </div>
    <div class="page-index">
        
        <span>
            
            
            <a class="page-num" href="/">1</a>
        </span>
        
        <span class="current">2</span>
        
        <span>
            <a class="page-num" href="/page/3/">3</a>
            
            <a class="page-num" href="/page/4">4</a>
            
            
        </span>
        
    </div>
    <div class="next">
        
        <a class="page-num" href="/page/3/">
            <i class="fa-solid fa-caret-right fa-fw"></i>
        </a>
        
    </div>
</div>

        </div>
    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://xds.asia/avatar/1.webp" alt="avatar">
        </div>
        <div class="name">IceOfSummer</div>
        <div class="description">
            <p>这个人很懒，没有个人简介</p>

        </div>
        
        
    </div>
</div>

    </div>
    
</div>
<script>
  (() => {
    const imageConfig = 'https://xds.asia/public/2023-2-6-8d14e464-2200-4e54-af81-0d9f25f55b3e.webp,https://xds.asia/public/2023-2-0-017e03b0-992c-4844-b28f-869799d32b96.webp,https://xds.asia/public/2023-2-0-66a241f4-eca3-45f3-b590-05aeed688f60.webp,https://xds.asia/public/2023-2-0-481f472f-e980-4cee-8ab8-ca66f5fd370a.webp,https://xds.asia/public/2023-2-2-2adf4d48-496a-49a4-8ca3-f64e035d8835.webp'
    if (!imageConfig) {
      return
    }
    const images = imageConfig.split(',')
    const bgElement = document.getElementById('home-background')
    const val = `background-image: url("${images[Math.floor((Math.random() * images.length))]}")`
    bgElement.setAttribute('style', val)
  })();

</script>

                <footer id="footer">
    <div class="footer-wrap">
        <div>
            &copy;
            2022 - 2023 IceOfSummerの博客
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;IceOfSummer
        </div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp; <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>

            </div>
            </transition>
            <div id="showimg">
                <img id="showimg-content">
            </div>
        </div>
        <script src="/js/functions.js"></script>
<script src="/js/particlex.js"></script>


    </body>
</html>
