
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>IceOfSummerの博客</title>
        <meta name="author" content="IceOfSummer" />
        <meta name="description" content="后面一辈子的博客都在这了！" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="https://selfb.asia/static/particlex/static/fonts.min.css" />
<script>
  const mixins = {};
  const h = (arg1, arg2, arg3) => {
    if (arg2.attrs) {
      Object.assign(arg2, arg2.attrs)
      Reflect.deleteProperty(arg2, 'attrs')
    }
    if (arg2.on) {
      Object.keys(arg2.on).forEach(key => {
        const head = key.charAt(0).toUpperCase()
        arg2['on' + head  + key.substring(1)] = arg2.on[key]
      })
      Reflect.deleteProperty(arg2, 'on')
    }
    return Vue.h(arg1, arg2, arg3)
  }
</script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

  <script src="/js/lib/toc.js"></script>



  <script src="/js/lib/lazy-load-support.js"></script>


    <meta name="generator" content="Hexo 7.1.1"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存&ensp;浏览器默认开启</p>
                    <img src="https://selfb.asia/static/particlex/images/loading.gif" />
                </div>
            </div>
            </transition>
            <transition name="into">
            <div id="main" v-show="!loading">
                <nav id="menu" ref="menu">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>ICEOFSUMMERの博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" v-show="showMenu" @click="showMenu = !showMenu"></div>
        <div class="title" @click="showMenu = !showMenu">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ICEOFSUMMERの博客</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenu">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

                <div id="home-head">
    <div id="home-background" ref="homeBackground" data-image="https://selfb.asia/public/2023-2-6-8d14e464-2200-4e54-af81-0d9f25f55b3e.webp,https://selfb.asia/public/2023-2-0-66a241f4-eca3-45f3-b590-05aeed688f60.webp,https://selfb.asia/images/2024/02/wallhaven-m3go6m_2560x1080.webp,https://selfb.asia/images/2024/02/wallhaven-6dgmvl_2560x1080.webp,https://selfb.asia/images/2024/01/wallhaven-jxl31y_2560x1440.webp"></div>
    
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>IceOfSummerの博客</h1>
                <h3>还是自己搭的博客靠谱</h3>
                <h5>后面一辈子的博客都在这了！</h5>
            </div>
        </span>
    </div>
    
</div>
<div id="home-posts-wrap"  ref="homePostsWrap">
    <div id="home-posts">
        <div id="posts">
            

<div class="post post-partial-show">
    <a href="/2023/04/10/netty-interview/">
        <h2 class="post-title">Netty面试题</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/4/10
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="1-为什么要用Netty"><a href="#1-为什么要用Netty" class="headerlink" title="1. 为什么要用Netty"></a>1. 为什么要用Netty</h1><p>Netty是一个基于Java NIO封装的高性能网络通信框架。它主要有以下优势：</p>
<ol>
<li>Netty提供了比NIO更简单的API<ul>
<li>很容易地实现Reactor模型</li>
</ul>
</li>
<li>Netty在NIO的基础上做出了很多优化<ul>
<li>内存池</li>
<li>零拷贝</li>
</ul>
</li>
<li>Netty内置了多种通信协议</li>
</ol>
<p>用官方的总结就是：<strong>Netty 成功地找到了一种在不妥协可维护性和性能的情况下实现易于开发，性能，稳定性和灵活性的方法。</strong></p>
<h1 id="2-Netty零拷贝"><a href="#2-Netty零拷贝" class="headerlink" title="2. Netty零拷贝"></a>2. Netty零拷贝</h1><p>Netty零拷贝主要在五个方面：</p>
<ol>
<li>Netty默认情况下使用直接内存，避免了从JVM堆内存拷贝到直接内存这一次拷贝，而是直接从直接使用直接内存进行Socket读写</li>
<li>Netty的文件传输调用了<code>FileRegion</code>包装的<code>transferTo</code>方法，可以直接将文件从缓冲区发送到目标Channel</li>
<li>Netty提供了<code>CompositeByteBuf</code>类，可以将多个ByteBuf合并为一个逻辑上的ByteBuf，避免了多个ByteBuf的拷贝。</li>
<li>通过<code>ByteBuf.wrap</code>方法，可以将byte[]数组、ByteBuffer包装成一个ByteBuf，从而避免了拷贝</li>
<li><code>ByteBuf</code>支持slice操作，可以将ByteBuf分解为多个共享同一存储区域的ByteBuf，避免了内存的拷贝</li>
</ol>
<h1 id="3-Netty内存管理"><a href="#3-Netty内存管理" class="headerlink" title="3. Netty内存管理"></a>3. Netty内存管理</h1><p>为了减少频繁向操作系统申请内存的情况，Netty会一次性申请一块较大的内存(由ChunkSize决定，默认为16M)，这块内存被称为<code>PoolChunk</code>。</p>
<p>而在一个<code>Chunk</code>下，又分为了一个一个页，叫做<code>Page</code>，默认为8K，即默认情况下一个Chunk有2048个页。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/422289486">超详细图文详解神秘的 Netty 高性能内存管理 - 知乎 (zhihu.com)</a></p>
<h2 id="3-1-PoolChunk如何管理Page"><a href="#3-1-PoolChunk如何管理Page" class="headerlink" title="3.1 PoolChunk如何管理Page"></a>3.1 PoolChunk如何管理Page</h2><p>PoolChunk通过一个完全二叉树来管理Page，这颗二叉树的深度为12(2^11 &#x3D; 2048)。</p>
<p>PoolChunk会维护一个<code>memeoryMap</code>数组，这个数组对应着每个节点，它的值代表这个节点之下的第几层还存在未分配的节点。</p>
<ul>
<li>比如说第9层的<code>memeoryMap</code>值为9，代表这个节点下面的子节点都未被分配</li>
<li>若第9层的<code>memeoryMap</code>为10，代表它本身不可被分配，但第10层有子节点可以被分配</li>
<li>若第9层的<code>memeoryMap</code>为12(树的高度)，代表当前节点下的所有子节点都不可分配</li>
</ul>
<p>那么我们怎么分配呢？</p>
<p>比如我们要15KB的空间，这里会先向上取8的整数，也就是16K，也就是2^1 * 8，拿到指数1，通过depth - 1 &#x3D; 12 - 1得到11，那么我们只需要去找<code>memeoryMap</code>为11的节点即可。在分配后，父节点的<code>memeoryMap</code>等于两个子节点的最小值。</p>
<h2 id="3-2-Page的管理"><a href="#3-2-Page的管理" class="headerlink" title="3.2 Page的管理"></a>3.2 Page的管理</h2><p>一个Page有8K，一般我们的应用程序是用不了这么多的，因此每个Page下会再次分隔。但这次分隔并不是以完全二叉树的形式，因为太占空间了，而是将这8K划分为等长的n份，一般会由<code>PoolSubpage</code>管理，一般分为两类：</p>
<ul>
<li>tiny：用于分配小于512字节的内存，一般大小为16B，32B，…，496B，每次增长为16的倍数，共32个。</li>
<li>small：用于分配大于等于512字节的内存，一般大小为512B、1K、2K，4K。</li>
</ul>
<p>对于每个块，会有一个bitMap去判断是否使用，可以理解为Java中的<code>BitSet</code></p>
<h2 id="3-3-Chunk的管理"><a href="#3-3-Chunk的管理" class="headerlink" title="3.3 Chunk的管理"></a>3.3 Chunk的管理</h2><p>每个PoolChunk通过<code>PoolArena</code>类来管理，这些Chunk被封装在<code>PoolChunkList</code>类中，这是一个双向链表。</p>
<p><code>PoolArena</code>有6个<code>PoolChunkList</code>：</p>
<ul>
<li>qInit：存储内存利用率 0-25% 的 chunk</li>
<li>q000：存储内存利用率 1-50% 的 chunk</li>
<li>q025：存储内存利用率 25-75% 的 chunk</li>
<li>q050：存储内存利用率 50-100% 的 chunk</li>
<li>q075：存储内存利用率 75-100%的 chunk</li>
<li>q100：存储内存利用率 100%的 chunk</li>
</ul>
<p><code>PoolArena</code>分配内存的顺序是：q050、q025、q000、qInit、q075</p>
<p>这样分配的好处是可以提高内存的利用率，以及减少链表的遍历次数。</p>
<h2 id="3-4-PoolThreadCache"><a href="#3-4-PoolThreadCache" class="headerlink" title="3.4 PoolThreadCache"></a>3.4 PoolThreadCache</h2><p>PoolThreadCache利用了ThreadLocal，每次线程在申请内存时都会优先从这里面获取。</p>
<ul>
<li>在释放已分配的内存块时，不放回到 Chunk 中，而是缓存到 ThreadCache 中</li>
<li>在分配内存块时，优先从 ThreadCache 获取。若无法获取到，再从 Chunk 中分配</li>
<li>通过这样的方式，既能提高分配效率，又尽可能的避免多线程的同步和竞争</li>
</ul>
<h1 id="4-直接内存回收原理"><a href="#4-直接内存回收原理" class="headerlink" title="4. 直接内存回收原理"></a>4. 直接内存回收原理</h1><p>每个ByteBuf都实现了一个<code>ReferenceCounted</code>接口，netty也是直接采用了引用计数法来进行内存回收。</p>
<h1 id="5-怎么判断ByteBuffer是否处于写模式或读模式"><a href="#5-怎么判断ByteBuffer是否处于写模式或读模式" class="headerlink" title="5. 怎么判断ByteBuffer是否处于写模式或读模式"></a>5. 怎么判断ByteBuffer是否处于写模式或读模式</h1><p><code>ByteBuffer</code>有三个重要参数：<code>position</code>、<code>limit</code>、<code>capacity</code>，而平常我们说的读模式或写模式只是用来方便我们理解的东西，真正在ByteBuffer的实现里并不存在什么读模式和写模式，也就是说你在”读模式下”仍然可以写。</p>
<p>例如下面的代码：</p>
<pre><code class="java">ByteBuffer byteBuffer = ByteBuffer.allocate(1024);

byte[] hello = &quot;hello&quot;.getBytes(StandardCharsets.UTF_8);
System.out.println(Arrays.toString(hello));
// &quot;write mode&quot;
byteBuffer.put(hello);
// &quot;read mode&quot;
byteBuffer.flip();
// write again
byteBuffer.put(&quot;h&quot;.getBytes(StandardCharsets.UTF_8));

while (byteBuffer.hasRemaining()) &#123;
    System.out.print(byteBuffer.get() + &quot; &quot;);
&#125;
</code></pre>
<p><font color=red>在”读模式”下去写的时候，并不会报错</font>，由于切换到了”读模式”，此时<code>position = 0，limit = 写模式的offset</code>，因此在写的时候，会从索引0处开始写，写完后，<code>position</code>变为1，我们再读的话也就只能从索引1读到4了。</p>
<p>如果硬要判断是不是”读模式”或”写模式”，可以根据<code>position</code>和<code>limit</code>的值进行判断：</p>
<ul>
<li>如<code>limit = capacity</code>，表示当前<strong>可能</strong>为写模式</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2023/04/10/netty-interview/" class="go-post">阅读全文</a>
</div>

<div class="post post-partial-show">
    <a href="/2023/04/02/mysql-interview/">
        <h2 class="post-title">MySql面试</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/4/2
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="1-B树和B-树之间的区别"><a href="#1-B树和B-树之间的区别" class="headerlink" title="1. B树和B+树之间的区别"></a>1. B树和B+树之间的区别</h1><blockquote>
<p>B树有些博客上会写成B-树，部分博客甚至读成了B减树，其实这个减号只是一个连接符，没有任何意义</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">B-Tree Visualization (usfca.edu)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">B+ Tree Visualization (usfca.edu)</a></p>
<p>B树和B+树的区别：</p>
<ul>
<li>B+树只会在叶子节点存储数据，而B树每个节点上都会有数据</li>
<li>B+树每个叶子节点之间有一个指针乡相连</li>
</ul>
<h1 id="2-高度为3的B-树能存多少条数据"><a href="#2-高度为3的B-树能存多少条数据" class="headerlink" title="2. 高度为3的B+树能存多少条数据"></a>2. 高度为3的B+树能存多少条数据</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6974225353371975693">MySQL系列（4）— InnoDB数据页结构 - 掘金 (juejin.cn)</a></p>
<p>在InnoDB中，索引默认使用的数据结构为B+树，而B+树里的每个节点都是一个页，默认的页大小为<code>16KB</code>。</p>
<p><img lazy="https://selfb.asia/public/post/2023-3-0-fed73c7c-b6fb-40e4-9b27-1a95fccd77c8.webp" alt="page"></p>
<h1 id="3-简单说一下InnoDB事务实现原理"><a href="#3-简单说一下InnoDB事务实现原理" class="headerlink" title="3. 简单说一下InnoDB事务实现原理"></a>3. 简单说一下InnoDB事务实现原理</h1><p>事务ACID：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>别名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Atomicity</strong></td>
<td>原子性</td>
<td>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生</td>
</tr>
<tr>
<td><strong>Consistency</strong></td>
<td>一致性</td>
<td>事务前后数据的完整性必须保持一致</td>
</tr>
<tr>
<td><strong>Isolation</strong></td>
<td>隔离性</td>
<td>事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离</td>
</tr>
<tr>
<td><strong>Durability</strong></td>
<td>持久性</td>
<td>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/48327345">一文了解InnoDB事务实现原理 - 知乎 (zhihu.com)</a></p>
<p>上面那个比较深入，下面这个比较好理解一些：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7012937835967692808">图解InnoDB事务实现原理｜Redo Log&amp;Undo Log - 掘金 (juejin.cn)</a></p>
<h1 id="4-MySql的三大日志是哪些"><a href="#4-MySql的三大日志是哪些" class="headerlink" title="4.MySql的三大日志是哪些"></a>4.MySql的三大日志是哪些</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7090530790156533773">MySQL三大日志(binlog,redolog,undolog)详解 - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903842505555981">聊聊MVCC和Next-key Locks - 掘金 (juejin.cn)</a></p>
<h1 id="5-MySql当前读和快照度"><a href="#5-MySql当前读和快照度" class="headerlink" title="5. MySql当前读和快照度"></a>5. MySql当前读和快照度</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7055073479866974238">mysql快照读原理实现 - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/166152616">MySQL 的可重复读到底是怎么实现的？图解 ReadView 机制 - 知乎 (zhihu.com)</a></p>
<p>这里其实有个问题，如果我只是单独的一条查询语句，没有开启事务，那么怎么去快照读呢？</p>
<p>这个我自己查了一下，众所周知，MySql里有一个autocommit属性，对于单条SQL，这个值一定是true，那么是不是说明我们每条SQL都会被认作是一个事务呢？</p>
<p>然后我在官方文档里查了一下：</p>
<p><img lazy="https://selfb.asia/public/interview/2023-2-0-bd1f976d-ac67-49a3-979b-1b9cd4fa2c6d.webp" alt="每条SQL都是一个单独的事务"></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-autocommit-commit-rollback.html">MySQL :: MySQL 5.7 Reference Manual :: 14.7.2.2 autocommit, Commit, and Rollback</a></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-autocommit-commit-rollback.html">MySQL :: MySQL 8.0 Reference Manual :: 15.7.2.2 autocommit, Commit, and Rollback</a></p>
<p>不管是8.0还是5.7，都是这样写的，那么就可以说的通了。每次执行单条SQL都会拿到一个事务id，然后再去进行快照读。</p>
<p>那么什么是当前读呢，使用下面的sql语句就是当前读：</p>
<pre><code class="sql"># 加共享锁
SELECT ... LOCK IN SHARE MODE 
# 加排它锁
SELECT ... FROM UPDATE
</code></pre>
<p>这两条语句的原理就是给对应的行加上<font color=red>共享锁(读锁)或排它锁(写锁)</font>，当有事务进行增删改时也会加排它锁，对于共享锁，允许多个事务持有(即允许多读)，对于排它锁，则只允许一个事务持有(即只能一个人写，且除了自己其它人都不能读)。</p>
<p>在排它锁和共享锁下读的的数据就是当前读，这份数据永远是最新的(此时若有其它事务想要修改相关的行，都会被阻塞)。其它状况则就是快照读了，通过MVCC创建ReadView进行数据的读取。</p>
<h1 id="6-MySql的MVCC"><a href="#6-MySql的MVCC" class="headerlink" title="6. MySql的MVCC"></a>6. MySql的MVCC</h1><p>MVCC(Multiversion Concurrency Control)多版本并发控制。</p>
<p>首先在在MVCC下，每个表都会多出几个隐藏的列，分别为隐藏主键(row_id)、事务id(trx_id)、回滚指针(roll_pointer)。</p>
<p>MVCC还有两个重要的组成：undo log(回滚日志)、ReadView。</p>
<p>更详细的就不说了，因为上面的链接里面都有，主要是下面这四个关系：</p>
<p>（1）当【版本链中记录的 trx_id 等于当前事务id（trx_id &#x3D; creator_trx_id）】时，说明版本链中的这个版本是当前事务修改的，所以该快照记录对当前事务可见。</p>
<p>（2）当【版本链中记录的 trx_id 小于活跃事务的最小id（trx_id &lt; min_trx_id）】时，说明版本链中的这条记录已经提交了，所以该快照记录对当前事务可见。</p>
<p>（3）当【版本链中记录的 trx_id 大于下一个要分配的事务id（trx_id &gt; max_trx_id）】时，该快照记录对当前事务不可见。</p>
<p>（4）当【版本链中记录的 trx_id 大于等于最小活跃事务id】且【版本链中记录的trx_id小于下一个要分配的事务id】（min_trx_id&lt;&#x3D; trx_id &lt; max_trx_id）时，如果版本链中记录的 trx_id 在活跃事务id列表 m_ids 中，说明生成 ReadView 时，修改记录的事务还没提交，所以该快照记录对当前事务不可见；否则该快照记录对当前事务可见。</p>
<h2 id="6-1-RepeatableRead是怎么实现的"><a href="#6-1-RepeatableRead是怎么实现的" class="headerlink" title="6.1 RepeatableRead是怎么实现的"></a>6.1 RepeatableRead是怎么实现的</h2><p>我们都知道，RepeatableRead相比ReadCommited能够避免不可重复读的问题(实际也能够避免幻读，是通过加间隙锁实现的)。</p>
<p>首先我们来看ReadCommitted，使用mysql执行如下指令(假如我们叫它事务A)</p>
<pre><code class="sql">set session transaction isolation level read committed;
begin;
update test set xid = 2 where id = 1;
# 等一会再提交
commit;
</code></pre>
<p>然后再开一个mysql执行如下指令(假如我们叫它事务B)：</p>
<pre><code class="sql">set session transaction isolation level read committed;
begin;
select * from test where id = 1;
# 提交上面那个指令后再执行下面这条
select * from test where id = 1;
</code></pre>
<p>这里就不放图了，大家都知道第二次读取会不一样。</p>
<p>这回我们再将隔离级别设置为RepeatableRead，并同样执行上面的指令。</p>
<p>这次执行后，<font color=red>发现两次查询的结果都是一样的</font>，而且在事务A执行更新后且没有提交时，B再去读，<font color=red>并没有发生阻塞，因为在修改数据的时候会加排它锁，在读的时候要么是当前读要么是快照读，</font>如果是当前读，那么读操作会堵塞，说明在B这里是快照读，是创建了ReadView的，通过ReadView有效地避免了不可重复读。</p>
<p>我们再用同样的方式去验证ReadCommited级别的读，发现同样是快照读，那么凭什么RepeatableRead不会读到新值，而ReadCommited会呢？</p>
<p>这里我画了一个流程图方便理解：</p>
<p><img lazy="https://selfb.asia/public/interview/2023-2-1-7f41e3a0-6d4e-42e8-b44e-d85eecdbd465.webp" alt="流程图"></p>
<p><del>图画的可能不太好，不过应该能看懂</del></p>
<p>网上大部分人讲的都是以ReadCommited级别为例子的，即m_ids里的事务提交后可读，但其实在RepeatableRead隔离级别下是读不了的，只能走undo_log进行回滚。</p>
<hr>
<p><font color=red>这里可能有点错误，在ReadCommited下可以读已经提交的事务，所以如果trx_id大于等于mid_id，只需要判断对应的事务是否已经提交(或者trx_id指向自己)就能读</font></p>
<h1 id="7-RepeatableRead真的不能避免幻读吗"><a href="#7-RepeatableRead真的不能避免幻读吗" class="headerlink" title="7. RepeatableRead真的不能避免幻读吗?"></a>7. RepeatableRead真的不能避免幻读吗?</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_71777195/article/details/126968432">美团三面：一直追问我， MySQL 幻读被彻底解决了吗？_肥肥技术宅的博客-CSDN博客</a></p>
<h1 id="8-为什么bin-log不能用作崩溃后的恢复"><a href="#8-为什么bin-log不能用作崩溃后的恢复" class="headerlink" title="8. 为什么bin_log不能用作崩溃后的恢复"></a>8. 为什么bin_log不能用作崩溃后的恢复</h1><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/463438061">mysql 为什么不能用binlog来做数据恢复？ - 知乎 (zhihu.com)</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2023/04/02/mysql-interview/" class="go-post">阅读全文</a>
</div>

<div class="post post-partial-show">
    <a href="/2023/03/28/redis-interview/">
        <h2 class="post-title">redis面试</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="1-Redis字典"><a href="#1-Redis字典" class="headerlink" title="1. Redis字典"></a>1. Redis字典</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/555430730">深入理解Redis 数据结构—字典 - 知乎 (zhihu.com)</a></p>
<blockquote>
<p>可以这样理解：Redis的字典就是java7的HashMap，即哈希表+链表</p>
</blockquote>
<p>Redis字典使用的哈希表结构如下：<a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/2.6/src/dict.h#L68-L73">redis&#x2F;dict.h at 2.6 · redis&#x2F;redis (github.com)</a></p>
<pre><code class="c++">typedef struct dictht &#123;
     // table 数组
    dictEntry **table;
    // 哈希表的大小
    unsigned long size;
    // 等于size-1，用于计算索引值, 这里说明size肯定是2的幂
    unsigned long sizemask;
    // 已有的键值对数量
    unsigned long used;
&#125; dictht;
</code></pre>
<p><code>dictEntry</code>就是哈希节点了：<a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/2.6/src/dict.h#L47-L55">redis&#x2F;dict.h at 2.6 · redis&#x2F;redis (github.com)</a></p>
<pre><code class="c++">typedef struct dictEntry &#123;
    // 键
    void *key;
    // 值   
    union &#123;
        void *val;
        uint64_t u64;
        int64_t s64;
    &#125; v;
    // 指向下一个哈希表节点，形成链表
    struct dictEntry *next;
&#125; dictEntry;
</code></pre>
<p>Redis中的字典则由<code>dict</code>组成：<a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/2.6/src/dict.h#L75-L81">redis&#x2F;dict.h at 2.6 · redis&#x2F;redis (github.com)</a></p>
<pre><code class="c++">typedef struct dict &#123;
    // 类型特定的函数，提供增删改查等功能 
    dictType *type;
   // 私有函数
    void *privdata;
    // 哈希表, 这里的二维是后面用来扩容的
    dictht ht[2];
    // rehash 索引，记录了当前扩容的进度
    int rehashidx; /* rehashing not in progress if rehashidx == -1 */
    // 用来记录当前运行的安全迭代器数，当不为0的时候表示有安全迭代器正在执行，这时候就会暂停rehash操作
    int iterators; /* number of iterators currently running */
&#125; dict;
</code></pre>
<p><img lazy="https://selfb.asia/public/post/2023-2-3-0c4958ca-7128-481d-807c-0c95384937ec.webp" alt="总览"></p>
<h1 id="2-Redis扩容与缩容"><a href="#2-Redis扩容与缩容" class="headerlink" title="2. Redis扩容与缩容"></a>2. Redis扩容与缩容</h1><p>我们用<code>ht[0].used/ht[0].size</code>表示负载因子</p>
<h2 id="2-1-扩容"><a href="#2-1-扩容" class="headerlink" title="2.1 扩容"></a>2.1 扩容</h2><ul>
<li><p>如果没有<strong>fork</strong>子进程在执行<strong>RDB</strong>或者<strong>AOF</strong>的持久化，一旦满足<strong>负载因子大于等于1</strong>，此时触发扩容；</p>
</li>
<li><p>如果有<strong>fork</strong>子进程在执行<strong>RDB</strong>或者<strong>AOF</strong>的持久化时，则需要满足<strong>负载因子大于5</strong>，此时触发扩容。</p>
</li>
</ul>
<p>Redis在扩容时使用的是渐进式哈希，即每次值移动一部分的数据到新的哈希表中。</p>
<p>在字典<code>dict</code>中，<code>dict.ht[0]</code>代表旧的哈希表，<code>dict.ht[1]</code>代表新的哈希表，每次扩容时会将容量乘2，同时<code>dict.rehashidx</code>代表rehash的进度，表示<code>dict.ht[0]</code>中，小于该索引的值都已经被移动到<code>dict.ht[1]</code>中了，此时需要在<code>dict.ht[1]</code>中进行相关的增删改查操作，反之则在<code>dict.ht[0]</code>中进行。</p>
<p>在扩容期间，每次进行增删改查都会将<code>dict.rehashidx</code>加一，并进行相关的rehash操作。</p>
<p>在扩容完毕后，将<code>dict.ht[0]</code>指向<code>dict.ht[1]</code>，并删除旧的哈希表。</p>
<h2 id="2-2-缩容"><a href="#2-2-缩容" class="headerlink" title="2.2 缩容"></a>2.2 缩容</h2><p>当负载因子小于0.1时，Redis就会对哈希表进行收缩操作。</p>
<p>相关操作和扩容一样，在<code>dict.ht[1]</code>处创建新的哈希表，之后再渐进式rehash。</p>
<h2 id="2-3-其它问题"><a href="#2-3-其它问题" class="headerlink" title="2.3 其它问题"></a>2.3 其它问题</h2><p>假如在rehash扩容的时候，我们一直插入，会不会导致再次扩容呢？</p>
<p>假设此时哈希表容量为<code>n</code>，元素数量为<code>n</code>，在扩容哈希表容量后变为<code>2n</code>，而对于Redis来说，完成rehash需要<code>2n - n = n</code>次操作，所以我们最多进行<code>n</code>次插入，插入完后元素数量也变为<code>2n</code>，再次触发扩容。</p>
<p>对于负载因子为5的时候，假设此时哈希表容量为<code>n</code>，元素数量为<code>5n + 1</code>，扩容后哈希表容量为<code>2n</code>，同样我们可以插入<code>n</code>个元素，此时元素数量变为<code>6n + 1</code>，负载因子为<code>(6n + 1) / 2n</code>约等于3，此时不会触发扩容。</p>
<h1 id="3-字典遍历"><a href="#3-字典遍历" class="headerlink" title="3. 字典遍历"></a>3. 字典遍历</h1><h2 id="3-1-全遍历"><a href="#3-1-全遍历" class="headerlink" title="3.1 全遍历"></a>3.1 全遍历</h2><p>使用如下指令就会执行全遍历，返回所有的key：</p>
<pre><code class="shell">keys *
</code></pre>
<p>优点：</p>
<ul>
<li>返回的key不会重复</li>
</ul>
<p>缺点：</p>
<ul>
<li>在遍历完前会阻塞服务器</li>
</ul>
<p>迭代器结构：</p>
<pre><code class="c++">typedef struct dictIterator &#123;
    dict *d; //迭代的字典
    int index; //当前迭代到Hash表中哪个索引值
    int table, safe; //table用于表示当前正在迭代的Hash表,即ht[0]与ht[1]，safe用于表示当前创建的是否为安全迭代器
    dictEntry *entry, *nextEntry;//当前节点，下一个节点
    /* unsafe iterator fingerprint for misuse detection. */
    long long fingerprint;//字典的指纹，当字典未发生改变时，该值不变，发生改变时则值也随着改变
&#125; dictIterator;
</code></pre>
<h3 id="3-3-1-安全迭代器和非安全迭代器"><a href="#3-3-1-安全迭代器和非安全迭代器" class="headerlink" title="3.3.1 安全迭代器和非安全迭代器"></a>3.3.1 安全迭代器和非安全迭代器</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/damanchen/article/details/89474695">Redis源码学习——安全迭代器和非安全迭代器（一）_damanchen的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/damanchen/article/details/89479299">Redis源码学习——安全迭代器和非安全迭代器（二）_damanchen的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/42156903">跋山涉水 —— 深入 Redis 字典遍历 - 知乎 (zhihu.com)</a></p>
<p>安全迭代器：</p>
<ul>
<li>迭代的时候不能rehash，可以进行过期键的删除</li>
</ul>
<p>非安全迭代器：</p>
<ul>
<li>迭代的时候可以rehash，但是不能进行删除等操作(字典只读)，通过<code>fingerprint</code>字段来判断字典是否发生变动</li>
</ul>
<h2 id="3-2-间接遍历"><a href="#3-2-间接遍历" class="headerlink" title="3.2 间接遍历"></a>3.2 间接遍历</h2><p>使用<code>scan</code>命令可以间接遍历，这个命令每次会返回一个下一个需要遍历的索引值：</p>
<pre><code class="shell">redis 127.0.0.1:6379&amp;gt; scan 0
1) &quot;17&quot;
2)  1) &quot;key:12&quot;
    2) &quot;key:8&quot;
    3) &quot;key:4&quot;
    4) &quot;key:14&quot;
    5) &quot;key:16&quot;
    6) &quot;key:17&quot;
    7) &quot;key:15&quot;
    8) &quot;key:10&quot;
    9) &quot;key:3&quot;
   10) &quot;key:7&quot;
   11) &quot;key:1&quot;
redis 127.0.0.1:6379&amp;gt; scan 17
1) &quot;0&quot;
2) 1) &quot;key:5&quot;
   2) &quot;key:18&quot;
   3) &quot;key:0&quot;
   4) &quot;key:2&quot;
   5) &quot;key:19&quot;
   6) &quot;key:13&quot;
   7) &quot;key:6&quot;
   8) &quot;key:9&quot;
   9) &quot;key:11&quot;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://redis.com.cn/commands/scan.html">Redis SCAN 命令</a></p>
<p>优点：</p>
<ul>
<li>一次只返回部分内容，响应较快，不会较长时间阻塞服务器</li>
</ul>
<p>缺点：</p>
<ul>
<li>可能会返回重复的值</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ldw201510803006/article/details/124052245">redis scan 命令底层原理（为什么会重复扫描？）_redis scan命令原理_柏油的博客-CSDN博客</a></p>
<p>这里第一次看可能会有这个疑问，我们打个比方：</p>
<p>遍历顺序：00 -&gt; 10 -&gt; 01 -&gt; 11</p>
<p>若正好遍历到10时扩容完毕了，则新顺序为：</p>
<p>000 -&gt; 100 -&gt; 010 -&gt; 110 -&gt; 001 -&gt; 101 -&gt; 011 -&gt; 111</p>
<p>此时我们在第三个位置，即010那里。</p>
<p>这时候可能就有疑问了：<font color=red>100那里不就遍历不到了吗？这不是丢数据了吗？</font></p>
<p>但这样其实是想多了，我们来看000和100，假如哈希表长度为4时，这两个索引下的元素会落到哪个哈希表下？</p>
<p>很明显，这两个位置的元素都会落到00这个索引的下面，因为哈希表长度为4时，索引位置的取法就是和<code>0x11</code>做与操作，而000和100低两位相同，所以它们俩在之前就在00处，以链表的形式组合在了一起，当遍历到10时，100也肯定被遍历了。</p>
<hr>
<p>总结一下就是<code>scan</code>命令会在哈希表缩容的时候造成数据重复，在rehash的期间也会造成重复。</p>
<p>在rehash期间调用<code>scan</code>，Redis会先扫小表，假如最终索引为v，然后会接着在大表中从v开始扫。</p>
<h1 id="4-五大基本数据类型"><a href="#4-五大基本数据类型" class="headerlink" title="4. 五大基本数据类型"></a>4. 五大基本数据类型</h1><p>在看数据类型前，我们再回顾一下entry的结构：</p>
<pre><code class="c++">typedef struct dictEntry &#123;
    // 键
    void *key;
    // 值   
    union &#123;
        void *val;
        uint64_t u64;
        int64_t s64;
    &#125; v;
    // 指向下一个哈希表节点，形成链表
    struct dictEntry *next;
&#125; dictEntry;
</code></pre>
<p>有没有发现一个问题：这个v代表值，那么这个值是个什么东西？？</p>
<p>这里其实是C语言的union，可以让多个变量使用同一个内存空间：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/595288133">C&#x2F;C++ union 使用教程 (常见操作与缺陷) - 知乎 (zhihu.com)</a></p>
<p>你可以这样理解：这里的v即有三种类型，即<code>void*</code>、<code>uint64_t</code>(64位无符号整数)、<code>int64_t</code>(64位有符号整数)。</p>
<p>对应<code>void*</code>你可以理解为Java中的<code>Object</code>类型，用它做参数的话就可以传入任意对象，更详细的信息可以看这篇博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/NeverLate_gogogo/article/details/79308195">void<em>（指针）的类型转换-专讲_void</em>转换_NeverLate_gogogo的博客-CSDN博客</a></p>
<hr>
<p>一般情况下<code>void*</code>都是指向<code>redisObject </code>：<a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/cb1717865804fdb0561e728d2f3a0a1138099d9d/README.md?plain=1#L323">redis&#x2F;README.md at cb1717865804fdb0561e728d2f3a0a1138099d9d · redis&#x2F;redis (github.com)</a></p>
<pre><code class="c++">struct redisObject &#123;
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */
    int refcount;
    void *ptr;
&#125;;
</code></pre>
<ul>
<li><p><code>type</code>：没啥好说的，每种数据结构的标识符</p>
</li>
<li><p><code>encoding</code>：编码</p>
<ul>
<li><p>以string来说，就有三种：<code>int</code> , <code>embstr</code> , <code>raw</code>：</p>
<pre><code class="shell">127.0.0.1:6379&amp;gt; SET counter 1
OK
127.0.0.1:6379&amp;gt; OBJECT ENCODING counter
&quot;int&quot;
127.0.0.1:6379&amp;gt; SET name &quot;Tom&quot;
OK
127.0.0.1:6379&amp;gt; OBJECT ENCODING name
&quot;embstr&quot;
127.0.0.1:6379&amp;gt; SETBIT bits 1 1
(integer) 0
127.0.0.1:6379&amp;gt; OBJECT ENCODING bits
&quot;raw&quot;
</code></pre>
</li>
</ul>
</li>
<li><p><code>lru</code>：给Redis做内存淘汰用</p>
</li>
<li><p><code>refcount</code>：引用计数，这个值为0的时候这个对象会被清除</p>
</li>
<li><p><code>ptr</code>：指向对象的实际表示，可能有多个指向同一个对象，一般还要配合encoding判断</p>
</li>
</ul>
<h2 id="4-1-String"><a href="#4-1-String" class="headerlink" title="4.1 String"></a>4.1 String</h2><p>Redis 的字符串是动态字符串，是可以修改的字符串，可以勉强理解为Java里的<code>StringBuilder</code>。</p>
<p>当字符串需要扩容时，有如下两种情况：</p>
<ul>
<li>当字符串长度小于 1M 时，扩容都是加倍现有的空间</li>
<li>超过 1M，扩容时一次只会多扩 1M 的空间</li>
</ul>
<p>字符串最大长度为512MB。<br>数据结构：<a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/cb1717865804fdb0561e728d2f3a0a1138099d9d/src/sds.h#L45">redis&#x2F;sds.h at cb1717865804fdb0561e728d2f3a0a1138099d9d · redis&#x2F;redis (github.com)</a></p>
<pre><code class="c++">#define SDS_TYPE_5  0
#define SDS_TYPE_8  1
#define SDS_TYPE_16 2
#define SDS_TYPE_32 3
#define SDS_TYPE_64 4
typedef char *sds;

struct __attribute__ ((__packed__)) sdshdr8 &#123;
    uint8_t len; /* used */
    uint8_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
&#125;;
struct __attribute__ ((__packed__)) sdshdr16 &#123;
    uint16_t len; /* used */
    uint16_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
&#125;;
struct __attribute__ ((__packed__)) sdshdr32 &#123;
    uint32_t len; /* used */
    uint32_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
&#125;;
struct __attribute__ ((__packed__)) sdshdr64 &#123;
    uint64_t len; /* used */
    uint64_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
&#125;;
</code></pre>
<p>我们可以发现，字符串结构体基本由<code>len</code>(已使用的长度)、<code>alloc</code>(最大长度&#x2F;分配的长度)、<code>flags</code>(标志信息)、<code>buf</code>(字符串内容)组成。</p>
<p>字符串拼接：<a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/cb1717865804fdb0561e728d2f3a0a1138099d9d/src/sds.c#LL483">redis&#x2F;sds.c at cb1717865804fdb0561e728d2f3a0a1138099d9d · redis&#x2F;redis · GitHub</a></p>
<pre><code class="c++">sds sdscatlen(sds s, const void *t, size_t len) &#123;
    size_t curlen = sdslen(s);
    s = sdsMakeRoomFor(s,len);
    // 内存不足
    if (s == NULL) return NULL;
    memcpy(s+curlen, t, len);
    sdssetlen(s, curlen+len);
    s[curlen+len] = &#39;\0&#39;;
    return s;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/269496479">要懂redis，首先得看懂sds（全网最细节的sds讲解） - 知乎 (zhihu.com)</a></p>
<h2 id="4-2-Hash"><a href="#4-2-Hash" class="headerlink" title="4.2 Hash"></a>4.2 Hash</h2><p>Hash类型有两种实现方式：</p>
<ul>
<li>ziplist 编码的哈希对象使用压缩列表作为底层实现</li>
<li>hashtable 编码的哈希对象使用字典作为底层实现</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chongfa2008/article/details/119537064">Redis之Hash数据结构底层原理_redis hash原理_不要迷恋发哥的博客-CSDN博客</a></p>
<h3 id="4-2-1-ziplist"><a href="#4-2-1-ziplist" class="headerlink" title="4.2.1 ziplist"></a>4.2.1 ziplist</h3><p><code>ziplist</code>的运作方式<font color=red>类似</font>于一个队列，当有一对键值时，先将值入队，再将键入队。</p>
<p>这种设计完全不符合哈希表的设计，所以只会在数据量较少时使用。</p>
<p>当发生如下情况时，<code>ziplist</code>会被转换为真正的哈希表(字典)：</p>
<ul>
<li>当hash中的数据项的数目超过512的时候，也就是ziplist数据项超过1024的时候</li>
<li>当hash中插入的任意一个value的长度超过了64的时候</li>
</ul>
<pre><code class="text">area        |&amp;lt;---- ziplist header ----&amp;gt;|&amp;lt;----------- entries -------------&amp;gt;|&amp;lt;-end-&amp;gt;|

size          4 bytes  4 bytes  2 bytes    ?        ?        ?        ?     1 byte
            +---------+--------+-------+--------+--------+--------+--------+-------+
component   | zlbytes | zltail | zllen | entry1 | entry2 |  ...   | entryN | zlend |
            +---------+--------+-------+--------+--------+--------+--------+-------+
                                       ^                          ^        ^
address                                |                          |        |
                                ZIPLIST_ENTRY_HEAD                |   ZIPLIST_ENTRY_END
                                                                  |
                                                         ZIPLIST_ENTRY_TAIL
</code></pre>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td>整个ziplist占用的内存字节数。</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td>到达ziplist表尾节点的偏移量。</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_t</td>
<td>ziplist中节点的数量。</td>
</tr>
<tr>
<td>entryX</td>
<td>？</td>
<td>ziplist的各个节点。</td>
</tr>
<tr>
<td>zlend</td>
<td>uint8_t</td>
<td>常量0b111111，用于标记ziplist末尾。</td>
</tr>
</tbody></table>
<p>每个<code>entry</code>的结构是这样的：</p>
<pre><code class="text">+-----------------------+----------+---------+
| previous_entry_length | encoding | content |
+-----------------------+----------+---------+
</code></pre>
<p><code>previous_entry_length</code>：前面一个节点的长度(字节)。若前面一个节点的长度小于254字节，则该属性占1个字节的宽度，反正则是占5个字节的宽度，第一个字节是常量<code>0xFE</code>(254)</p>
<p><code>encoding</code>：记录content的类型</p>
<p><code>content</code>：保存节点的值</p>
<p>我们可以发现<code>ziplist</code>不能从头开始遍历，因为每个节点的长度都是不一样的，在遍历的时候需要根据zltail的值<font color=red>从尾部开始向前遍历</font>。</p>
<h3 id="4-2-2-hashtable"><a href="#4-2-2-hashtable" class="headerlink" title="4.2.2 hashtable"></a>4.2.2 hashtable</h3><p>hashtable就和Redis最外层的字典是差不多的了。</p>
<h2 id="4-3-List"><a href="#4-3-List" class="headerlink" title="4.3 List"></a>4.3 List</h2><p>对于List同样也有两种编码：</p>
<ul>
<li>ziplist：压缩列表</li>
<li>linkedlist：双向链表</li>
</ul>
<p>满足如下条件时，压缩列表会被转换为双向链表：</p>
<ul>
<li>试图往列表新添加一个字符串值，且这个字符串的长度超过 server.list_max_ziplist_value （默认值为 64 ）</li>
<li>ziplist 包含的节点超过 server.list_max_ziplist_entries （默认值为 512 ）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/102422311">Redis列表list 底层原理 - 知乎 (zhihu.com)</a></p>
<h2 id="4-4-Set"><a href="#4-4-Set" class="headerlink" title="4.4 Set"></a>4.4 Set</h2><p>Set拥有两种编码：</p>
<ul>
<li>intset：使用数组维护set，数组是有序的</li>
<li>hashtable：直接使用哈希表维护set</li>
</ul>
<p>满足如下条件时intset将会被转换成hashtable：</p>
<ul>
<li>保存了非整型的值</li>
<li>元素数量超过了512个</li>
</ul>
<h3 id="4-4-1-intset"><a href="#4-4-1-intset" class="headerlink" title="4.4.1 intset"></a>4.4.1 intset</h3><p>数据结构：</p>
<pre><code class="c++">typedef struct intset &#123;
    // 这个编码用来决定contents的大小
    uint32_t encoding;
    uint32_t length;
    int8_t contents[];
&#125; intset;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/971b177fa338fe06cb67a930c6e54467d29ec44f/src/intset.h#L35">redis&#x2F;intset.h at 971b177fa338fe06cb67a930c6e54467d29ec44f · redis&#x2F;redis (github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6998360508462006308">面试官：说说Redis中Set数据类型的底层实现 - 掘金 (juejin.cn)</a></p>
<h2 id="4-5-zset-Sorted-Set"><a href="#4-5-zset-Sorted-Set" class="headerlink" title="4.5 zset(Sorted Set)"></a>4.5 zset(Sorted Set)</h2><p>zset有两种实现：</p>
<ul>
<li>zipList：压缩列表</li>
<li>skipList：跳表</li>
</ul>
<p>满足如下条件时zipList会转换成skipList：</p>
<ul>
<li>节点数量大于等于128(server.zset_max_ziplist_entries)</li>
<li>节点的长度大于等64(server.zset_max_ziplist_value)</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangxuelei036/article/details/106272680">Redis 跳跃表skiplist(深入理解,面试再也不用怕)_redis skiplist_妖四灵.Shuen的博客-CSDN博客</a></p>
<p><img lazy="https://selfb.asia/public/interview/2023-2-4-70e28030-df93-4d4d-9043-9e3afd7b975b.webp" alt="跳表"></p>
<ul>
<li>header：指向跳跃表的表头节点</li>
<li>tail：指向跳跃表的表尾节点</li>
<li>level：记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</li>
<li>length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)</li>
</ul>
<p>节点数据结构：</p>
<pre><code class="c++">typedef struct zskiplistNode &#123;
    // 当前保存的值
    sds ele;
    // 分值，用于排序
    double score;
    // 前一个节点
    struct zskiplistNode *backward;
    // 当前层节点
    struct zskiplistLevel &#123;
        struct zskiplistNode *forward;
        // 跳表的跨度
        unsigned long span;
    &#125; level[];
&#125; zskiplistNode;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/971b177fa338fe06cb67a930c6e54467d29ec44f/src/server.h#L1329">redis&#x2F;server.h at 971b177fa338fe06cb67a930c6e54467d29ec44f · redis&#x2F;redis (github.com)</a></p>
<pre><code class="c++">// 跳表
typedef struct zskiplist &#123;
    struct zskiplistNode *header, *tail;
    // 跳表的长度
    unsigned long length;
    // 最高层数
    int level;
&#125; zskiplist;

// zset数据结构
typedef struct zset &#123;
    dict *dict;
    zskiplist *zsl;
&#125; zset;
</code></pre>
<h1 id="5-Redis持久化方式"><a href="#5-Redis持久化方式" class="headerlink" title="5. Redis持久化方式"></a>5. Redis持久化方式</h1><h2 id="5-1-RDB"><a href="#5-1-RDB" class="headerlink" title="5.1 RDB"></a>5.1 RDB</h2><p>RDB即Redis Database，它会将Redis某一时刻的数据以文件的形式全量备份到磁盘。</p>
<p>Redis提供了两个指令来生成RDB，一个是SAVE，这个命令会阻塞主线程，直到RDB生成完毕。</p>
<p>另外一个则是BGSAVE，这时会fork一个子进程去专门负责写入RDB。</p>
<p>在读取数据时用到了写时复制(COW)技术，fork创建出的子进程，<strong>与父进程共享内存空间</strong>。也就是说，如果子进程<strong>不对内存空间进行写入操作的话，内存空间中的数据并不会复制给子进程</strong>，这样创建子进程的速度就很快了！</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34556414/article/details/108399543">LInux fork的写时复制(copy on write)_fork写时复制_富士康质检员张全蛋的博客-CSDN博客</a></p>
<h2 id="5-2-AOF"><a href="#5-2-AOF" class="headerlink" title="5.2 AOF"></a>5.2 AOF</h2><p>AOF即Append Only File，它会记录在redis服务器上执行过的命令来实现持久化的目的。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ysocean/p/9114267.html">Redis详解（七）—— AOF 持久化 - YSOcean - 博客园 (cnblogs.com)</a></p>
<p>Redis默认每秒执行一次AOF的写入。</p>
<h3 id="5-2-1-AOF重写"><a href="#5-2-1-AOF重写" class="headerlink" title="5.2.1 AOF重写"></a>5.2.1 AOF重写</h3><p>为了防止AOF文件过大，当AOF的文件大小超过设定的阈值后，Redis就会启动AOF的文件压缩。</p>
<p>压缩前：</p>
<pre><code class="shell">sadd animals &quot;cat&quot;
sadd animals &quot;dog&quot;
sadd animals &quot;cat&quot;
sadd animals &quot;lion&quot;
</code></pre>
<p>压缩后：</p>
<pre><code class="shell">sadd animals &quot;cat&quot; &quot;dog&quot; &quot;lion&quot;
</code></pre>
<h1 id="6-内存"><a href="#6-内存" class="headerlink" title="6. 内存"></a>6. 内存</h1><h2 id="6-1-内存过期策略"><a href="#6-1-内存过期策略" class="headerlink" title="6.1 内存过期策略"></a>6.1 内存过期策略</h2><p>Redis对于过期的key有两种删除策略：</p>
<ul>
<li>定期删除</li>
<li>惰性删除</li>
</ul>
<h3 id="6-1-1-定期删除"><a href="#6-1-1-定期删除" class="headerlink" title="6.1.1 定期删除"></a>6.1.1 定期删除</h3><p>Redis会将每个设置了过期时间的key放到一个独立的字典中，以后会定期按照某种算法来遍历里面的key。</p>
<p>默认每秒进行10次扫描，每次会随机选取一些key，然后删除其中过期的key，若某次删除的数量超过了选取的<code>1/4</code>，则会重复这一步骤。</p>
<h3 id="6-1-2-惰性删除"><a href="#6-1-2-惰性删除" class="headerlink" title="6.1.2 惰性删除"></a>6.1.2 惰性删除</h3><p>在客户端访问某个key时，若这个key过期，则会将其删除。</p>
<h2 id="6-2-内存淘汰策略"><a href="#6-2-内存淘汰策略" class="headerlink" title="6.2 内存淘汰策略"></a>6.2 内存淘汰策略</h2><p>当没有可以被删除的key，且Redis内存不足时，此时会根据内存淘汰策略删除一些没有过期的key。</p>
<ol>
<li><p>noeviction：当内存使用超过配置的时候会返回错误，不会驱逐任何键</p>
</li>
<li><p>allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键</p>
</li>
<li><p>volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键</p>
</li>
<li><p>allkeys-random：加入键的时候如果过限，从所有key随机删除</p>
</li>
<li><p>volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐</p>
</li>
<li><p>volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键</p>
</li>
<li><p>volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键</p>
</li>
<li><p>allkeys-lfu：从所有键中驱逐使用频率最少的键</p>
</li>
</ol>
<p>关于LRU和LFU，在redisObject里会保存相关的参数：</p>
<pre><code class="c++">struct redisObject &#123;
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */
    int refcount;
    void *ptr;
&#125;;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/cb1717865804fdb0561e728d2f3a0a1138099d9d/README.md?plain=1#L323">redis&#x2F;README.md at cb1717865804fdb0561e728d2f3a0a1138099d9d · redis&#x2F;redis (github.com)</a></p>
<ul>
<li>当使用LRU算法时，<code>lru</code>整个值都用来表示相关访问时间。</li>
<li>当使用LFU算法时，低8位表示访问频率，高16位表示上一次访问时间</li>
</ul>
<h3 id="6-2-1-LRU"><a href="#6-2-1-LRU" class="headerlink" title="6.2.1 LRU"></a>6.2.1 LRU</h3><p>LRU即Least Recently Used-最近最少使用算法。</p>
<p>LRU会维护一个双向链表，对于新加入的数据或者最近被访问的数据，它们会被存&#x2F;移动到链表头部，当内存不足的时候删除链表尾部的数据。</p>
<p>优点：</p>
<ul>
<li>好实现</li>
</ul>
<p>缺点：</p>
<ul>
<li>冷数据可能会把热数据顶掉</li>
</ul>
<h3 id="6-2-2-LFU"><a href="#6-2-2-LFU" class="headerlink" title="6.2.2 LFU"></a>6.2.2 LFU</h3><p>LFU即Least Frequently Used-最不经常使用。其核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/submissions/detail/419560284/">LFU 缓存 - 提交记录 - 力扣（LeetCode）</a></p>
<p>Redis的LFU和上面的LFU有一些不一样，一般的LFU有如下缺点：</p>
<ul>
<li>新增的缓存容易被删除</li>
</ul>
<p>而Redis在此基础上会将每个数据的访问次数设置为<code>5</code>，每次访问会根据其上次访问时间<font color=red>扣除</font>一定的访问次数，然后再根据生成的一个随机数，决定是否对访问次数字段加一：</p>
<pre><code class="c++">uint8_t LFULogIncr(uint8_t counter) &#123;
    if (counter == 255) return 255;
    double r = (double)rand()/RAND_MAX;
    double baseval = counter - LFU_INIT_VAL;
    if (baseval &amp;lt; 0) baseval = 0;
    // 访问次数越多，加一的概率越小
    double p = 1.0/(baseval*server.lfu_log_factor+1);
    if (r &amp;lt; p) counter++;
    return counter;
&#125;
</code></pre>
<p>其中<code>server.lfu_log_factor</code>默认为10。</p>
<p>因为访问计数器的长度为8位，最大为255，如果每次访问都加一，很可能会导致溢出。</p>
<p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/413038">16 | LFU算法和其他算法相比有优势吗？ (geekbang.org)</a></p>
<h1 id="7-Redis集群"><a href="#7-Redis集群" class="headerlink" title="7. Redis集群"></a>7. Redis集群</h1><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1751001">一文搞懂 Redis 的三种集群方案 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p>Redis支持三种集群方案：</p>
<ul>
<li>主从复制</li>
<li>哨兵模式</li>
<li>Cluster模式</li>
</ul>
<h2 id="7-1-主从复制"><a href="#7-1-主从复制" class="headerlink" title="7.1 主从复制"></a>7.1 主从复制</h2><p>主从复制主要由一个主数据库与一个或多个从数据库实例组成。</p>
<p>客户端可对主数据库进行读写操作，对从数据库进行读操作，主数据库写入的数据会实时自动同步给从数据库。</p>
<p>具体工作机制为：</p>
<ol>
<li>slave启动后，向master发送SYNC命令，master接收到SYNC命令后通过bgsave保存快照，并使用缓冲区记录保存快照这段时间内执行的写命令</li>
<li>master将保存的快照文件发送给slave，并继续记录执行的写命令</li>
<li>slave接收到快照文件后，加载快照文件，载入数据</li>
<li>master快照发送完后开始向slave发送缓冲区的写命令，slave接收命令并执行，完成复制初始化</li>
<li>此后master每次执行一个写命令都会同步发送给slave，保持master与slave之间数据的一致性</li>
</ol>
<p>优点：</p>
<ul>
<li>master能自动将数据同步到slave，可以进行读写分离，分担master的读压力</li>
<li>master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>难以支持在线扩容，Redis的容量受限于单机配置</p>
</li>
<li><p>master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题</p>
</li>
<li><p>不具备自动容错与恢复功能，master或slave的宕机都可能导致客户端请求失败，需要等待机器重启或手动切换客户端IP才能恢复</p>
</li>
</ul>
<h2 id="7-2-哨兵模式"><a href="#7-2-哨兵模式" class="headerlink" title="7.2 哨兵模式"></a>7.2 哨兵模式</h2><p>哨兵模式基于主从复制模式，只是引入了哨兵来监控与自动处理故障。</p>
<p>哨兵顾名思义，就是来为Redis集群站哨的，一旦发现问题能做出相应的应对处理。其功能包括:</p>
<ol>
<li>监控master、slave是否正常运行</li>
<li>当master出现故障时，能自动将一个slave转换为master（大哥挂了，选一个小弟上位）</li>
<li>多个哨兵可以监控同一个Redis，哨兵之间也会自动监控</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/06ab9daf921d">Redis哨兵（Sentinel）模式 - 简书 (jianshu.com)</a></p>
<p>优点：</p>
<ol>
<li>哨兵模式基于主从复制模式，所以主从复制模式有的优点，哨兵模式也有</li>
<li>哨兵模式下，master挂掉可以自动进行切换，系统可用性更高</li>
</ol>
<p>缺点：</p>
<ol>
<li>同样也继承了主从模式难以在线扩容的缺点，Redis的容量受限于单机配置</li>
<li>需要额外的资源来启动sentinel进程，实现相对复杂一点，同时slave节点作为备份节点不提供服务</li>
</ol>
<h2 id="7-3-Cluster模式"><a href="#7-3-Cluster模式" class="headerlink" title="7.3 Cluster模式"></a>7.3 Cluster模式</h2><p>Cluster采用无中心结构,它的特点如下：</p>
<ol>
<li>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽</li>
<li>节点的fail是通过集群中超过半数的节点检测失效时才生效</li>
<li>客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可</li>
</ol>
<p>Cluster模式的具体工作机制：</p>
<ol>
<li>在Redis的每个节点上，都有一个插槽（slot），取值范围为0-16383</li>
<li>当我们存取key的时候，Redis会根据CRC16的算法得出一个结果，然后把结果对16384求余数，这样每个key都会对应一个编号在0-16383之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作</li>
<li>为了保证高可用，Cluster模式也引入主从复制模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点</li>
<li>当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点都宕机了，那么该集群就无法再提供服务了</li>
</ol>
<p>Cluster模式集群节点最小配置6个节点(3主3从，因为需要半数以上)，其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p>
<h1 id="8-分布式锁"><a href="#8-分布式锁" class="headerlink" title="8. 分布式锁"></a>8. 分布式锁</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/v123411739/article/details/114501792?spm=1001.2014.3001.5502">面试必问的分布式锁，你懂了吗？_几年经验会问分布式锁_程序员囧辉的博客-CSDN博客</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2023/03/28/redis-interview/" class="go-post">阅读全文</a>
</div>

<div class="post post-partial-show">
    <a href="/2023/03/23/springboot-interview/">
        <h2 class="post-title">springboot源码</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/23
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><p>通过<code>AnnotationConfigApplicationContext</code>可以创建一个Spring容器：</p>
<pre><code class="java">public class MySpringApplication &#123;

    public static void main(String[] args) &#123;
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);

        UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;);
        userService.test();
    &#125;

&#125;

@ComponentScan(&quot;pers.xds.springboot&quot;)
public class AppConfig &#123;
&#125;
</code></pre>
<h2 id="1-1-生命周期"><a href="#1-1-生命周期" class="headerlink" title="1.1 生命周期"></a>1.1 生命周期</h2><p>可以在<code>AbstractAutowireCapableBeanFactory#doCreateBean</code>中看到完整的bean生成流程。</p>
<p>大致分为如下过程：</p>
<p>1.对Bean进行实例化</p>
<p>2.依赖注入</p>
<p>3.如果Bean实现了<code>BeanNameAware</code>接口，Spring将调用<code>setBeanName()</code>，设置 <code>Bean</code>的 id（xml文件中bean标签的id）</p>
<p>4.如果Bean实现了<code>BeanFactoryAware</code>接口，Spring将调用<code>setBeanFactory()</code></p>
<p>5.如果Bean实现了<code>ApplicationContextAware</code>接口，Spring容器将调用<code>setApplicationContext()</code></p>
<p>6.如果存在<code>BeanPostProcessor</code>，Spring将调用它们的<code>postProcessBeforeInitialization</code>（预初始化）方法，在Bean初始化前对其进行处理</p>
<p>7.如果Bean实现了<code>InitializingBean</code>接口，Spring将调用它的<code>afterPropertiesSet</code>方法，然后调用xml定义的 init-method方法(初始化)，两个方法作用类似，都是在初始化 bean 的时候执行</p>
<p>8.如果存在<code>BeanPostProcessor</code>，Spring将调用它们的<code>postProcessAfterInitialization</code>（后初始化）方法，在Bean初始化后对其进行处理</p>
<p>9.Bean初始化完成，供应用使用，直到应用被销毁</p>
<p>10.如果Bean实现了<code>DisposableBean</code>接口，Spring将调用它的<code>destory</code>方法，然后调用在xml中定义的 <code>destory-method</code>方法，这两个方法作用类似，都是在Bean实例销毁前执行。</p>
<h2 id="1-2-BeanFactory和FactoryBean的区别"><a href="#1-2-BeanFactory和FactoryBean的区别" class="headerlink" title="1.2 BeanFactory和FactoryBean的区别"></a>1.2 BeanFactory和FactoryBean的区别</h2><p><code>BeanFactory</code>：管理Bean的容器，Spring中生成的Bean都是由这个接口的实现来管理的。</p>
<p><code>FactoryBean</code>：让开发者以编程的方式来创建一个bean，一般用于创建比较复杂的bean。</p>
<h2 id="1-3-Bean注入容器有哪些方式"><a href="#1-3-Bean注入容器有哪些方式" class="headerlink" title="1.3 Bean注入容器有哪些方式"></a>1.3 Bean注入容器有哪些方式</h2><p>1、使用<code>@Configuration</code>与<code>@Bean</code>注解</p>
<p>2、使用<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Component</code> 注解标注该类，然后启用<code>@ComponentScan</code>自动扫描</p>
<p>3、使用<code>@Import</code> 方法，使用@Import注解把bean导入到当前容器中。</p>
<h2 id="1-4-Bean的作用域"><a href="#1-4-Bean的作用域" class="headerlink" title="1.4 Bean的作用域"></a>1.4 Bean的作用域</h2><p>1、singleton：单例，Spring中的bean默认都是单例的。</p>
<p>2、prototype：每次请求都会创建一个新的bean实例。</p>
<p>3、request：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</p>
<p>4、session：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP session内有效。</p>
<p>5、application：限定一个Bean的作用域为<code>ServletContext</code>的生命周期。该作用域仅适用于web的Spring WebApplicationContext环境。</p>
<h2 id="1-5-自动装配的方式"><a href="#1-5-自动装配的方式" class="headerlink" title="1.5 自动装配的方式"></a>1.5 自动装配的方式</h2><p><code>@Autowired</code>注解会优先根据类型来注入，当有多个bean时，会尝试根据变量名来注入(byname)，如果没有找到就抛出异常。</p>
<p>可以通过<code>@Qualifier</code>来指定要注入的bean的名称。</p>
<p><code>@Resource</code>注解会优先byname，找不到再byType。</p>
<h2 id="1-6-Bean和-Component的区别"><a href="#1-6-Bean和-Component的区别" class="headerlink" title="1.6 @Bean和@Component的区别"></a>1.6 @Bean和@Component的区别</h2><p><code>@Bean</code>只能作用于方法上，表示这个方法会返回一个Bean，一般需要配合<code>@Configuration</code>使用。</p>
<p><code>@Component</code>只能作用于类型上，表示这个类会作为组件类，并告诉Spring要为这个类创建bean。</p>
<h3 id="1-6-1-Bean必须在-Configuration里使用吗"><a href="#1-6-1-Bean必须在-Configuration里使用吗" class="headerlink" title="1.6.1 @Bean必须在@Configuration里使用吗?"></a>1.6.1 @Bean必须在@Configuration里使用吗?</h3><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/40256702/spring-bean-can-still-work-without-configuration">Spring: @Bean can still work without @Configuration - Stack Overflow</a></p>
<p><code>@Bean</code>在<code>@Configuration</code>表示的类里使用时，Spring会为其自动创建一个动态代理对象，在同一个配置类中可以直接调用方法来获取Bean：</p>
<pre><code class="java">@Configuration
public class ExampleConfiguration &#123;
    
    @Bean
    public Datasource datasource() &#123;
        BasicDatasource datasource = new BasicDatasource();
        // ...
        return datasource;
    &#125;
    
    public PlatformTransactionManager transactionManager() &#123;
          // 注意这里是直接调用了方法，每次调用都会返回同一个bean，并不会多次创建
        return new DataSourceTransactionManager(datasource());
    &#125;
    
&#125;
</code></pre>
<p>而在非<code>@Configuration</code>下定义的<code>@Bean</code>会以Lite Mode运作，在该模式下调用其它<code>@Bean</code>方法时，则是普通的方法调用(没有代理对象去拦截调用)。</p>
<h2 id="1-7-Spring怎么解决循环依赖问题"><a href="#1-7-Spring怎么解决循环依赖问题" class="headerlink" title="1.7 Spring怎么解决循环依赖问题"></a>1.7 Spring怎么解决循环依赖问题</h2><p>对于构造器注入的循环依赖：Spring处理不了，直接抛出<code>BeanCurrentlylnCreationException</code>异常。</p>
<p>非单例循环依赖：无法处理。</p>
<p>单例模式下属性注入的循环依赖会通过三级缓存处理循环依赖：</p>
<p><code>singletonObjects</code>：完成了初始化的单例对象map，bean name –&gt; bean instance</p>
<p><code>earlySingletonObjects</code>：完成实例化未初始化的单例对象map，bean name –&gt; bean instance</p>
<p><code>singletonFactories</code>： 单例对象工厂map，bean name –&gt; ObjectFactory，存放 bean 工厂对象</p>
<p>具体的执行逻辑可以在<code>DefaultSingletonBeanRegistry</code>中看到，这里贴出核心方法：</p>
<pre><code class="java">protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null &amp;&amp; this.isSingletonCurrentlyInCreation(beanName)) &#123;
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;
            synchronized(this.singletonObjects) &#123;
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) &#123;
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) &#123;
                        ObjectFactory&amp;lt;?&amp;gt; singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        if (singletonFactory != null) &#123;
                            singletonObject = singletonFactory.getObject();
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            this.singletonFactories.remove(beanName);
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;

    return singletonObject;
&#125;
</code></pre>
<h2 id="1-8-Spring的单例Bean是否有线程安全问题"><a href="#1-8-Spring的单例Bean是否有线程安全问题" class="headerlink" title="1.8 Spring的单例Bean是否有线程安全问题"></a>1.8 Spring的单例Bean是否有线程安全问题</h2><p>当多个用户同时请求一个服务时，容器会给每一个请求分配一个线程，这时多个线程会并发执行该请求对应的业务逻辑，如果业务逻辑有对单例状态的修改（体现为此单例的成员属性），则必须考虑线程安全问题。</p>
<p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，那么不会有线程安全问题；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。</p>
<p><strong>无状态bean和有状态bean</strong></p>
<ul>
<li>有实例变量的bean，可以保存数据，是非线程安全的。</li>
<li>没有实例变量的对象。不能保存数据，是线程安全的。</li>
</ul>
<p>在Spring中无状态的Bean适合用单例模式，这样可以共享实例提高性能。有状态的Bean在多线程环境下不安全，一般用Prototype模式或者使用ThreadLocal解决线程安全问题。</p>
<h2 id="1-9-Spring容器的启动过程"><a href="#1-9-Spring容器的启动过程" class="headerlink" title="1.9 Spring容器的启动过程"></a>1.9 Spring容器的启动过程</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35190492/article/details/110383213">阿里面试真题：Spring容器启动流程_spring启动流程面试题_敖 丙的博客-CSDN博客</a></p>
<h1 id="2-AOP"><a href="#2-AOP" class="headerlink" title="2. AOP"></a>2. AOP</h1><p>常见的动态代理有两种：</p>
<ul>
<li><p>JDK动态代理：基于Java反射机制实现，必须要实现了接口的业务类才生成代理对象。</p>
</li>
<li><p>CGLIB动态代理：基于ASM机制实现，通过生成业务类的子类作为代理类。</p>
</li>
</ul>
<p>JDK Proxy的优势：</p>
<p>​	最小化依赖关系、代码实现简单、简化开发和维护、JDK原生支持，比CGLIB更加可靠，随JDK版本平滑升级。而字节码类库通常需要进行更新以保证在新版Java上能够使用。</p>
<p>CGLIB的优势：</p>
<p>​	无需实现接口，达到代理类无侵入，只操作关心的类，而不必为其他相关类增加工作量。高性能。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/115744594">Java动态代理之一CGLIB详解 - 知乎 (zhihu.com)</a></p>
<h1 id="3-Spring事务"><a href="#3-Spring事务" class="headerlink" title="3. Spring事务"></a>3. Spring事务</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903608224333838">可能是最漂亮的Spring事务管理详解 - 掘金 (juejin.cn)</a></p>
<h1 id="4-MyBatis工作原理"><a href="#4-MyBatis工作原理" class="headerlink" title="4. MyBatis工作原理"></a>4. MyBatis工作原理</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6993253212853633055#heading-8">一文搞懂Mybatis架构与工作原理 - 掘金 (juejin.cn)</a></p>
<ol>
<li><p>加载映射文件(通过动态代理和xml为接口生成对应的代理类)</p>
</li>
<li><p>构造会话工程(SqlSessionFactory)</p>
</li>
<li><p>创建会话对象(SqlSession)</p>
<pre><code class="java">try (SqlSession session = sqlSessionFactory.openSession()) &#123;
  BlogMapper mapper = session.getMapper(BlogMapper.class);
  Blog blog = mapper.selectBlog(101);
&#125;
</code></pre>
</li>
<li><p>Executor执行器</p>
<p>Mybatis会通过Executor去执行SQL语句。一般这里面会有缓存的实现。</p>
</li>
<li><p>MappedStatement对象</p>
<p>对映射信息的封装，它存储了一个SQL对应的所有信息。Mybatis 通过解析 XML 和 mapper 接口上的注解，生成 sql 对应的 MappedStatement 实例</p>
</li>
<li><p>输入参数映射</p>
</li>
<li><p>输出参数映射</p>
</li>
</ol>
<p>​	将数据库输出转换为 <code>Map</code>，<code>List</code>或自定义的类型</p>
<p><img lazy="https://selfb.asia/public/post/2023-3-2-ca9cc3cd-cb95-4437-8182-2476f326260d.webp"></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2023/03/23/springboot-interview/" class="go-post">阅读全文</a>
</div>

<div class="post post-partial-show">
    <a href="/2023/03/22/computer-network/">
        <h2 class="post-title">计网常用知识总结</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/22
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="1-网际协议IP"><a href="#1-网际协议IP" class="headerlink" title="1. 网际协议IP"></a>1. 网际协议IP</h1><h2 id="1-1-IPv4"><a href="#1-1-IPv4" class="headerlink" title="1.1 IPv4"></a>1.1 IPv4</h2><p><img lazy="https://selfb.asia/public/post/2023-2-4-7b4a02b9-5e93-4d3e-80e8-ec67eda52d2a.webp" alt="IP报文格式"></p>
<ul>
<li>版本：IPv4为4，IPv6即为6</li>
<li>首部长度：<font color=red>单位为4字节</font>，因此头部最长为15个4字节，即60字节</li>
<li>区分服务（旧版叫服务类型）：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/160937314">QoS分类和标记 - 知乎 (zhihu.com)</a></li>
<li>总长度：总长度包括首部和数据的长度。</li>
<li>标识：用于路由器分片重组。同一个分片的标志值相同，不同的分片的标识值不同。</li>
<li>标志：占3位，但只两位可以使用<ul>
<li>最低位(可以理解为最右边)：记为MF(More Fragment)。MF &#x3D; 1标识后面<strong>还有分片</strong>。</li>
<li>中间位：记为DF(Don’t Fragment)，意为<strong>不能分片</strong>，只有当DF &#x3D; 0时才允许分片。</li>
</ul>
</li>
<li>片偏移：较长的分组在分片后，某片在原分组中的相对位置，单位是8字节。<ul>
<li>例如有一个数据有3800字节，被分为了1400字节、1400字节、1000字节(忽略了首部)，则它们的片偏移分别为：<code>0/8 = 0</code>，<code>1400 / 8 = 175</code>，<code>2800 / 8 = 350</code></li>
</ul>
</li>
<li>生存时间：一般称为TTL(Time To Live)，标明数据报在网络中的<strong>寿命</strong>。最初的设计是以<font color=red>秒</font>作为TTL的单位，每经过一个路由器就减掉响应的时间，到零时则会被丢弃。然而随着技术的进步，路由器处理数据报所需的时间不断在缩短，一般都远远小于1秒，后来就把TTL字段的功能改为“跳数限制”，即每经过一个路由器，就将该值减一，到零时就删除掉，最大值为255</li>
<li>协议：见下表</li>
</ul>
<table>
<thead>
<tr>
<th>协议名</th>
<th align="center">ICMP</th>
<th align="center">IGMP</th>
<th align="center">IP</th>
<th align="center">TCP</th>
<th align="center">EGP</th>
<th align="center">IGP</th>
<th align="center">UDP</th>
<th align="center">IPv6</th>
<th align="center">ESP</th>
<th align="center">ICMP-IPv6</th>
</tr>
</thead>
<tbody><tr>
<td>字段值</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center"><font color=red>6</font></td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center"><font color=red>17</font></td>
<td align="center">41</td>
<td align="center">50</td>
<td align="center">58</td>
</tr>
</tbody></table>
<ul>
<li>首部校验和：这个字段只检验数据报的首部，但不包括数据部分。具体运算方式是把首部按16字节划分，然后按照反码算术相加得到。</li>
<li>源地址：发送IP数据报主机的IP地址</li>
<li>目的地址：占32位。接收IP数据报主机的IP地址</li>
<li>选项：由于选项很难背用到，而且也会增加路由器的开销，因此在IPv6中，IP数据报首部长度被改为固定值了</li>
</ul>
<h2 id="1-2-IPv6"><a href="#1-2-IPv6" class="headerlink" title="1.2 IPv6"></a>1.2 IPv6</h2><p><img lazy="https://selfb.asia/public/post/2023-2-4-48265f3c-796f-4a2e-a261-b4f4ed0cd38f.webp" alt="IPv6"></p>
<ul>
<li><p>版本：IPv6肯定就是6了</p>
</li>
<li><p>通信量类(Traffic Class)：这是为了区分不同的IPv6数据报的类别或优先级，和IPv4的区分服务字段的作用相似。</p>
</li>
<li><p>流标号(Flow Label)：IPv6的一个新的机制是支持资源预分配，并且允许路由器把每个数据报与一个给定的资源分配相联系。</p>
</li>
<li><p>有效荷载长度：它指明IPv6数据报除基本首部以为的字节数（所有扩展首部都算在有效荷载之内）。</p>
</li>
<li><p>下一个首部：它相当于IPv4的协议字段或可选字段。</p>
</li>
<li><p>跳数限制：用来防止数据报在网络中无期限的存在。</p>
</li>
</ul>
<h1 id="2-TCP"><a href="#2-TCP" class="headerlink" title="2. TCP"></a>2. TCP</h1><h2 id="2-1-三次握手"><a href="#2-1-三次握手" class="headerlink" title="2.1 三次握手"></a>2.1 三次握手</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/430799766">深入浅出TCP三次握手 （多图详解） - 知乎 (zhihu.com)</a></p>
<p>主要是要记住客户端和服务端的状态：</p>
<ul>
<li>客户端：CLOSED -&gt; SYN-SENT -&gt; ESTABLISHED</li>
<li>服务端：CLOSED -&gt; SYN-RCVD -&gt; ESTABLISHED</li>
</ul>
<p>之后在每次通信时，下次消息的<code>seq</code>为对方上次消息的<code>ack</code>，下次消息的<code>ack</code>为对方上次消息的<code>seq + 总数据长度</code>(同一个<code>seq</code>可能会有多个消息)</p>
<p><font color=red>在握手时，虽然数据长度为0，在理解时需要将其”当做”长度为1。</font></p>
<h2 id="2-2-四次挥手"><a href="#2-2-四次挥手" class="headerlink" title="2.2 四次挥手"></a>2.2 四次挥手</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LOOKTOMMER/article/details/121307137">TCP四次挥手详解_‍oOoOoOooOO的博客-CSDN博客</a></p>
<p>客户端和服务端的状态：</p>
<ul>
<li>客户端(主动关闭的那一方)：ESTABLISHED -&gt; FIN_WAIT -&gt; TIME_WAIT(等待2ms) -&gt; CLOSE</li>
<li>服务端(响应关闭的那一方)：ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK -&gt; CLOSE</li>
</ul>
<p>这里在主动关闭的那一方需要等待2MSL，原因如下：</p>
<ul>
<li><p>首先占用该端口，因为IP报文在网络中的生存时间是有限的，让旧的报文全部在网络中被丢弃</p>
</li>
<li><p>若主动关闭的那一方的ACK没有被服务端收到，此时服务端再次返回一个FIN报文，会被客户端错误的以为是一个错误报文而导致状态重置(发送RST报文)</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/99943313">TCP的TIME_WAIT状态 - 知乎 (zhihu.com)</a></p>
<h2 id="2-3-TCP报文格式"><a href="#2-3-TCP报文格式" class="headerlink" title="2.3 TCP报文格式"></a>2.3 TCP报文格式</h2><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6441.html">TCP报文格式解析 (biancheng.net)</a></p>
<p>其中可能比较难记的就是8个标志位的前两个了，其实只需要记住全称就不容易忘了：</p>
<ul>
<li>CWR：Congestion Window Reduce</li>
<li>ECE：ECN Echo，全称Explicit Congestin Notification Echo</li>
</ul>
<p>里面还有个校验和，这里需要知道是怎么算的。在计算机网络第八版P218中介绍了UDP的检验和计算：</p>
<ul>
<li>首先在数据报前添加一个伪首部</li>
<li>将校验和的位置置零</li>
<li>以16位2个字节为单位，如果由于数据的长度导致无法满足该条件，则在数据部分后补零即可。之后将所有数据相加，如果溢出，则添加到低位(二进制反码运算求和)</li>
<li>将结果取反添加到校验和的位置</li>
</ul>
<p>在验证时同样使用上面的方法，但不用把校验位置零，若计算结果最终为全1，则表示数据无误</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42560250/article/details/113526217">TCP&#x2F;UDP伪头部详解_tcp 伪头部_M、k的博客-CSDN博客</a></p>
<p>需要注意的是IP报文的校验不包含数据。</p>
<h1 id="3-路由器和交换机"><a href="#3-路由器和交换机" class="headerlink" title="3. 路由器和交换机"></a>3. 路由器和交换机</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/jiPMUk6zUdOY6eKxAjNDbQ">如果让你来设计网络 (qq.com)</a></p>
<p>交换机是工作在数据链路层的，它根据每台设备的MAC地址来转发数据。</p>
<p>而路由器是工作在网络层的，它负责IP报文的转发。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2023/03/22/computer-network/" class="go-post">阅读全文</a>
</div>

<div class="post post-partial-show">
    <a href="/2023/03/19/interview2/">
        <h2 class="post-title">面试题记录2</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/19
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <ul>
<li><a href="/2023/03/14/interview/">第一期</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/uRUsKF/">八股文｜后端｜MySQL｜答案 - 力扣（LeetCode）</a></p>
<h1 id="1-Redis的内存淘汰算法"><a href="#1-Redis的内存淘汰算法" class="headerlink" title="1. Redis的内存淘汰算法"></a>1. Redis的内存淘汰算法</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/crazymakercircle/article/details/115360829">Redis 内存淘汰策略 （史上最全）_redis内存淘汰策略_40岁资深老架构师尼恩的博客-CSDN博客</a></p>
<h1 id="2-Redis主从复制"><a href="#2-Redis主从复制" class="headerlink" title="2. Redis主从复制"></a>2. Redis主从复制</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bilson99/article/details/118732296">Redis（主从复制、哨兵模式、集群）的讲解_redis集哨兵模式哪个节点负责读取数据_五条悟的小迷妹的博客-CSDN博客</a></p>
<h1 id="3-Redis的持久化方式"><a href="#3-Redis的持久化方式" class="headerlink" title="3. Redis的持久化方式"></a>3. Redis的持久化方式</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Violet_201903027/article/details/100145168">Redis有哪几种持久化方式？优缺点是什么_Listener_code的博客-CSDN博客</a></p>
<h1 id="4-Redis常见的性能问题和解决方案"><a href="#4-Redis常见的性能问题和解决方案" class="headerlink" title="4. Redis常见的性能问题和解决方案"></a>4. Redis常见的性能问题和解决方案</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7207406497541455929">Redis 常见性能问题和解决方案 - 掘金 (juejin.cn)</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2023/03/19/interview2/" class="go-post">阅读全文</a>
</div>


            <div class="page-current">
    <div class="prev">
        
        <a class="page-num" href="/page/2/">
            <i class="fa-solid fa-caret-left fa-fw"></i>
        </a>
        
    </div>
    <div class="page-index">
        
        <span>
            
            
                
                <a class="page-num" href="/">1</a>
                
                
            
            <a class="page-num" href="/page/2/">2</a>
        </span>
        
        <span class="current">3</span>
        
        <span>
            <a class="page-num" href="/page/4/">4</a>
            
            
        </span>
        
    </div>
    <div class="next">
        
        <a class="page-num" href="/page/4/">
            <i class="fa-solid fa-caret-right fa-fw"></i>
        </a>
        
    </div>
</div>

        </div>
    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://selfb.asia/images/2024/02/avator.webp" alt="avatar" />
        </div>
        <div class="name">IceOfSummer</div>
        <div class="description">
            <p>这个人很懒，没有个人简介</p>

        </div>
        
        
    </div>
</div>

    </div>
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 IceOfSummerの博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;<a target="_blank" rel="noopener" href="https://github.com/IceOfSummer">IceOfSummer</a>
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/IceOfSummer/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
    </body>
</html>
