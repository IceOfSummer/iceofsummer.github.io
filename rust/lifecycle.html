
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>生命周期 | IceOfSummerの博客</title>
        <meta name="author" content="IceOfSummer" />
        <meta name="description" content="后面一辈子的博客都在这了！" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="https://selfb.asia/static/particlex/static/fonts.min.css" />
<script>
  const mixins = {};
  const h = (arg1, arg2, arg3) => {
    if (arg2.attrs) {
      Object.assign(arg2, arg2.attrs)
      Reflect.deleteProperty(arg2, 'attrs')
    }
    if (arg2.on) {
      Object.keys(arg2.on).forEach(key => {
        const head = key.charAt(0).toUpperCase()
        arg2['on' + head  + key.substring(1)] = arg2.on[key]
      })
      Reflect.deleteProperty(arg2, 'on')
    }
    return Vue.h(arg1, arg2, arg3)
  }
</script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

  <script src="/js/lib/toc.js"></script>



  <script src="/js/lib/lazy-load-support.js"></script>


    <meta name="generator" content="Hexo 7.1.1"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存&ensp;浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            </transition>
            <transition name="into">
            <div id="main" v-show="!loading">
                <nav id="menu" ref="menu">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>ICEOFSUMMERの博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" v-show="showMenu" @click="showMenu = !showMenu"></div>
        <div class="title" @click="showMenu = !showMenu">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ICEOFSUMMERの博客</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenu">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

                <div class="article">
    <div>
        <h1>生命周期</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/1/30
        </span>
        
        <span class="category">
            <a href="/2023/12/04/rust/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Rust
            </a>
        </span>
        
        
    </div>
    
    <toc-component></toc-component>
    <div class="content" v-pre id="main-content">
        <h1 id="悬垂指针和生命周期"><a href="#悬垂指针和生命周期" class="headerlink" title="悬垂指针和生命周期"></a>悬垂指针和生命周期</h1><p>生命周期的主要作用是避免悬垂引用，它会导致程序引用了本不该引用的数据：</p>
<pre><code class="rust">&#123;
    let r;

    &#123;
        let x = 5;
        r = &amp;x;
    &#125;

    println!(&quot;r: &#123;&#125;&quot;, r);
&#125;
</code></pre>
<p><code>r</code> 引用了内部花括号中的 <code>x</code> 变量，但是 <code>x</code> 会在内部花括号 <code>&#125;</code> 处被释放，因此回到外部花括号后，<code>r</code> 会引用一个无效的 <code>x</code>。</p>
<p>此处 <code>r</code> 就是一个悬垂指针，它引用了提前被释放的变量 <code>x</code>，编译器在编译时就会报错。</p>
<p>#借用检查</p>
<p>为了保证 Rust 的所有权和借用的正确性，Rust 使用了一个借用检查器(Borrow checker)，来检查我们程序的借用正确性：</p>
<pre><code class="rust">&#123;
    let r;                // ---------+-- &#39;a
                          //          |
    &#123;                     //          |
        let x = 5;        // -+-- &#39;b  |
        r = &amp;x;           //  |       |
    &#125;                     // -+       |
                          //          |
    println!(&quot;r: &#123;&#125;&quot;, r); //          |
&#125;                         // ---------+
</code></pre>
<p>这段代码和之前的一模一样，唯一的区别在于增加了对变量生命周期的注释。这里，<code>r</code> 变量被赋予了生命周期 <code>&#39;a</code>，<code>x</code> 被赋予了生命周期 <code>&#39;b</code>，从图示上可以明显看出生命周期 <code>&#39;b</code> 比 <code>&#39;a</code> 小很多。</p>
<p>在编译期，Rust 会比较两个变量的生命周期，结果发现 <code>r</code> 明明拥有生命周期 <code>&#39;a</code>，但是却引用了一个小得多的生命周期 <code>&#39;b</code>，在这种情况下，编译器会认为我们的程序存在风险，因此拒绝运行。</p>
<p>如果想要编译通过，也很简单，只要 ‘b 比 ‘a 大就好。总之，x 变量只要比 r 活得久，那么 r 就能随意引用 x 且不会存在危险：</p>
<pre><code class="rust">&#123;
    let x = 5;            // ----------+-- &#39;b
                          //           |
    let r = &amp;x;           // --+-- &#39;a  |
                          //   |       |
    println!(&quot;r: &#123;&#125;&quot;, r); //   |       |
                          // --+       |
&#125;                         // ----------+
</code></pre>
<h2 id="函数中的生命周期"><a href="#函数中的生命周期" class="headerlink" title="函数中的生命周期"></a>函数中的生命周期</h2><pre><code class="rust">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;
    if x.len() &gt; y.len() &#123;
        x
    &#125; else &#123;
        y
    &#125;
&#125;

fn main() &#123;
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is &#123;&#125;&quot;, result);
&#125;
</code></pre>
<p>这段代码看似没有问题，实际上编译期就会报错：</p>
<pre><code class="log">error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;
  |               ----     ----     ^ expected named lifetime parameter // 参数需要一个生命周期
  |
  = help: this function&#39;s return type contains a borrowed value, but the signature does not say whether it is
  borrowed from `x` or `y`
  = 帮助： 该函数的返回值是一个引用类型，但是函数签名无法说明，该引用是借用自 `x` 还是 `y`
help: consider introducing a named lifetime parameter // 考虑引入一个生命周期
  |
9 | fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str &#123;
  |           ^^^^    ^^^^^^^     ^^^^^^^     ^^^
</code></pre>
<p>因为在此处编译器无法确定返回值的生命周期，因为两个参数的生命周期可能并不一样。</p>
<p>要想正常使用该函数，则需要我们手动进行生命周期标注。</p>
<h1 id="生命周期标注语法"><a href="#生命周期标注语法" class="headerlink" title="生命周期标注语法"></a>生命周期标注语法</h1><p>标记的生命周期只是为了取悦编译器，让编译器不要难为我们，实际上对代码的运行不会有任何影响。</p>
<p>声明周期以<code>&#39;</code>开头，名称往往是一个单独的小写字母，一般从<code>a</code>开始：</p>
<pre><code class="rust">&amp;i32        // 一个引用
&amp;&#39;a i32     // 具有显式生命周期的引用
&amp;&#39;a mut i32 // 具有显式生命周期的可变引用
</code></pre>
<p>例如下面的函数声明：</p>
<pre><code class="rust">fn useless&lt;&#39;a&gt;(first: &amp;&#39;a i32, second: &amp;&#39;a i32) &#123;&#125;
</code></pre>
<p>此处生命周期标注仅仅说明，这两个参数 first 和 second 至少活得和’a 一样久，实际上，<code>&#39;a</code>的声明周期是<code>first</code>和<code>second</code>这两个的交集。</p>
<p>再例如之前的例子，加上生命周期后：</p>
<pre><code class="rust">fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str &#123;
    if x.len() &gt; y.len() &#123;
        x
    &#125; else &#123;
        y
    &#125;
&#125;
</code></pre>
<p>此处 <code>longest</code> 函数并不知道 x 和 y 具体会活多久，但是只要知道它们的作用域至少能持续 ‘a 这么长就行：</p>
<pre><code class="rust">fn main() &#123;
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    &#123;
        // string1 和 string2 生命周期的交集开始
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
        // string1 和 string2 生命周期的交集结束
    &#125;
    // error 在生命周期交集外使用
    println!(&quot;The longest string is &#123;&#125;&quot;, result);
&#125;
</code></pre>
<h2 id="深入了解"><a href="#深入了解" class="headerlink" title="深入了解"></a>深入了解</h2><p>生命周期的声明不需要为全部的变量提供：</p>
<pre><code class="rust">fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;str) -&gt; &amp;&#39;a str &#123;
    x
&#125;
</code></pre>
<p>例如上面的函数中，返回值的声明周期和参数<code>x</code>保持一致，和<code>y</code>的生命周期没有任何关系。</p>
<hr>
<p><strong>函数的返回值如果是一个引用类型，那么它的生命周期只会来源于：</strong></p>
<ul>
<li>函数参数的生命周期</li>
<li>函数体中某个新建引用的生命周期</li>
</ul>
<p>如果是后者，则是典型的悬垂引用，此时是无法通过编译的，只能考虑返回所有权而不是引用。</p>
<h1 id="结构体中的生命周期"><a href="#结构体中的生命周期" class="headerlink" title="结构体中的生命周期"></a>结构体中的生命周期</h1><pre><code class="rust">struct ImportantExcerpt&lt;&#39;a&gt; &#123;
    part: &amp;&#39;a str,
&#125;

fn main() &#123;
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split(&#39;.&#39;).next().expect(&quot;Could not find a &#39;.&#39;&quot;);
    let i = ImportantExcerpt &#123;
        part: first_sentence,
    &#125;;
&#125;
</code></pre>
<p>ImportantExcerpt 结构体中有一个引用类型的字段 part，因此需要为它标注上生命周期。结构体的生命周期标注语法跟泛型参数语法很像，需要对生命周期参数进行声明 &lt;’a&gt;。该生命周期标注说明，结构体 ImportantExcerpt 所引用的字符串 str 必须比该结构体活得更久。</p>
<p>从 main 函数实现来看，ImportantExcerpt 的生命周期从第 4 行开始，到 main 函数末尾结束，而该结构体引用的字符串从第一行开始，也是到 main 函数末尾结束，可以得出结论结构体引用的字符串活得比结构体久，这符合了编译器对生命周期的要求，因此编译通过。</p>
<p>例如如下代码无法通过编译：</p>
<pre><code class="rust">#[derive(Debug)]
struct ImportantExcerpt&lt;&#39;a&gt; &#123;
    part: &amp;&#39;a str,
&#125;

fn main() &#123;
    let i;
    &#123;
        let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
        let first_sentence = novel.split(&#39;.&#39;).next().expect(&quot;Could not find a &#39;.&#39;&quot;);
        i = ImportantExcerpt &#123;
            part: first_sentence,
        &#125;;
    &#125;
    println!(&quot;&#123;:?&#125;&quot;,i);
&#125;
</code></pre>
<p>观察代码，可以看出结构体比它引用的字符串活得更久，引用字符串在内部语句块末尾 } 被释放后，println! 依然在外面使用了该结构体，因此会导致无效的引用。</p>
<h1 id="生命周期消除"><a href="#生命周期消除" class="headerlink" title="生命周期消除"></a>生命周期消除</h1><p>对于编译器来说，每一个引用类型都有一个生命周期，在大部分情况下，编译器会自动识别并标注：</p>
<pre><code class="rust">fn first_word(s: &amp;str) -&gt; &amp;str &#123;
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() &#123;
        if item == b&#39; &#39; &#123;
            return &amp;s[0..i];
        &#125;
    &#125;

    &amp;s[..]
&#125;
</code></pre>
<p>该函数的参数和返回值都是引用类型，尽管我们没有显式的为其标注生命周期，编译依然可以通过。</p>
<p>对于 first_word 函数，它的返回值是一个引用类型，那么该引用只有两种情况：</p>
<ul>
<li>从参数获取</li>
<li>从函数体内部新创建的变量获取</li>
</ul>
<p>如果是后者，就会出现悬垂引用，编译器会报错。因此只剩一种情况：返回值的引用是获取自参数，这就意味着参数和返回值的生命周期是一样的。</p>
<h2 id="消除规则"><a href="#消除规则" class="headerlink" title="消除规则"></a>消除规则</h2><p>编译器使用三条消除规则来确定哪些场景不需要显式地去标注生命周期：</p>
<ol>
<li><p>每一个引用参数都会获得独自的生命周期</p>
<p> 例如一个引用参数的函数就有一个生命周期标注: fn foo&lt;’a&gt;(x: &amp;’a i32)，两个引用参数的有两个生命周期标注:fn foo&lt;’a, ‘b&gt;(x: &amp;’a i32, y: &amp;’b i32), 依此类推。</p>
</li>
<li><p>若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期，也就是所有返回值的生命周期都等于该输入生命周期</p>
<p> 例如函数 fn foo(x: &amp;i32) -&gt; &amp;i32，x 参数的生命周期会被自动赋给返回值 &amp;i32，因此该函数等同于 fn foo&lt;’a&gt;(x: &amp;’a i32) -&gt; &amp;’a i32</p>
</li>
<li><p>若存在多个输入生命周期，且其中一个是 &amp;self 或 &amp;mut self，则 &amp;self 的生命周期被赋给所有的输出生命周期</p>
<p> 拥有 &amp;self 形式的参数，说明该函数是一个 <code>方法</code>，该规则让方法的使用便利度大幅提升。</p>
</li>
</ol>
<h1 id="方法中的生命周期"><a href="#方法中的生命周期" class="headerlink" title="方法中的生命周期"></a>方法中的生命周期</h1><p>方法的生命周期和泛型声明相似：</p>
<pre><code class="rust">struct ImportantExcerpt&lt;&#39;a&gt; &#123;
    part: &amp;&#39;a str,
&#125;

impl&lt;&#39;a&gt; ImportantExcerpt&lt;&#39;a&gt; &#123;
    fn level(&amp;self) -&gt; i32 &#123;
        3
    &#125;
&#125;
</code></pre>
<ul>
<li>impl 中必须使用结构体的完整名称，包括 &lt;’a&gt;，因为生命周期标注也是结构体类型的一部分！</li>
<li>方法签名中，往往不需要标注生命周期，得益于生命周期消除的第一和第三规则：<pre><code class="rust">impl&lt;&#39;a&gt; ImportantExcerpt&lt;&#39;a&gt; &#123;
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str &#123;
        println!(&quot;Attention please: &#123;&#125;&quot;, announcement);
        self.part
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h2 id="复杂用法"><a href="#复杂用法" class="headerlink" title="复杂用法"></a>复杂用法</h2><pre><code class="rust">impl&lt;&#39;a&gt; ImportantExcerpt&lt;&#39;a&gt; &#123;
    fn announce_and_return_part&lt;&#39;b&gt;(&amp;&#39;a self, announcement: &amp;&#39;b str) -&gt; &amp;&#39;b str &#123;
        println!(&quot;Attention please: &#123;&#125;&quot;, announcement);
        self.part
    &#125;
&#125;
</code></pre>
<p>该代码编译器会报错，因为编译器无法知道 ‘a 和 ‘b 的关系，因为<code>self.part</code>的生命周期为<code>&#39;a</code>，而返回值的生命周期应该为<code>&#39;b</code>。</p>
<p>如果想要让该代码通过编译，则需要让<code>&#39;a</code>的生命周期大于<code>&#39;b</code>的生命周期即可：</p>
<pre><code class="rust">impl&lt;&#39;a: &#39;b, &#39;b&gt; ImportantExcerpt&lt;&#39;a&gt; &#123;
    fn announce_and_return_part(&amp;&#39;a self, announcement: &amp;&#39;b str) -&gt; &amp;&#39;b str &#123;
        println!(&quot;Attention please: &#123;&#125;&quot;, announcement);
        self.part
    &#125;
&#125;
</code></pre>
<p><code>&#39;a: &#39;b</code>，是生命周期约束语法，跟泛型约束非常相似，用于说明 ‘a 必须比 ‘b 活得久。</p>
<p>也可以通过<code>where</code>进行声明：</p>
<pre><code class="rust">impl&lt;&#39;a&gt; ImportantExcerpt&lt;&#39;a&gt; &#123;
    fn announce_and_return_part&lt;&#39;b&gt;(&amp;&#39;a self, announcement: &amp;&#39;b str) -&gt; &amp;&#39;b str
    where
        &#39;a: &#39;b,
    &#123;
        println!(&quot;Attention please: &#123;&#125;&quot;, announcement);
        self.part
    &#125;
&#125;
</code></pre>
<h1 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h1><p>在 Rust 中有一个非常特殊的生命周期，那就是 <code>&#39;static</code>，拥有该生命周期的引用可以和整个程序活得一样久。</p>
<p>我们常见的字符串字面量就是<code>&#39;static</code>的生命周期：</p>
<pre><code class="rust">let s: &amp;&#39;static str = &quot;我没啥优点，就是活得久，嘿嘿&quot;;
</code></pre>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 IceOfSummerの博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;<a target="_blank" rel="noopener" href="https://github.com/IceOfSummer">IceOfSummer</a>
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/IceOfSummer/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        
<script
    src="https://giscus.app/client.js"
    data-repo="IceOfSummer/iceofsummer.github.io"
    data-repo-id="R_kgDOJFU7OQ"
    data-category="Announcements"
    data-category-id="DIC_kwDOJFU7Oc4CUyC7"
    data-mapping="title"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin
    async
></script>





        
    </body>
</html>
