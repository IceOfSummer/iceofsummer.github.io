
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>Macro 宏编程 | IceOfSummerの博客</title>
        <meta name="author" content="IceOfSummer" />
        <meta name="description" content="后面一辈子的博客都在这了！" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="https://selfb.asia/static/particlex/static/fonts.min.css" />
<script>
  const mixins = {};
  const h = (arg1, arg2, arg3) => {
    if (arg2.attrs) {
      Object.assign(arg2, arg2.attrs)
      Reflect.deleteProperty(arg2, 'attrs')
    }
    if (arg2.on) {
      Object.keys(arg2.on).forEach(key => {
        const head = key.charAt(0).toUpperCase()
        arg2['on' + head  + key.substring(1)] = arg2.on[key]
      })
      Reflect.deleteProperty(arg2, 'on')
    }
    return Vue.h(arg1, arg2, arg3)
  }
</script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

  <script src="/js/lib/toc.js"></script>



  <script src="/js/lib/lazy-load-support.js"></script>


    <meta name="generator" content="Hexo 7.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存&ensp;浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            </transition>
            <transition name="into">
            <div id="main" v-show="!loading">
                <nav id="menu" ref="menu">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>ICEOFSUMMERの博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" v-show="showMenu" @click="showMenu = !showMenu"></div>
        <div class="title" @click="showMenu = !showMenu">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ICEOFSUMMERの博客</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenu">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

                <div class="article">
    <div>
        <h1>Macro 宏编程</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/6/24
        </span>
        
        <span class="category">
            <a href="/2023/12/04/rust/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Rust
            </a>
        </span>
        
        
    </div>
    
    <toc-component></toc-component>
    <div class="content" v-pre id="main-content">
        <p>在 Rust 中宏分为两大类：声明式宏( declarative macros ) <code>macro_rules!</code> 和三种过程宏( procedural macros ):</p>
<ul>
<li><code>#[derive]</code>，在之前多次见到的派生宏，可以为目标结构体或枚举派生指定的代码，例如 <code>Debug</code> 特征</li>
<li>类属性宏(Attribute-like macro)，用于为目标添加自定义的属性</li>
<li>类函数宏(Function-like macro)，看上去就像是函数调用</li>
</ul>
<h1 id="宏和函数的区别"><a href="#宏和函数的区别" class="headerlink" title="宏和函数的区别"></a>宏和函数的区别</h1><h2 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h2><p>从根本上来说，宏是通过一种代码来生成另一种代码，例如 <code>derive</code> 属性，就会自动为结构体派生出相应特征所需的代码，例如 <code>#[derive(Debug)]</code>，还有熟悉的 <code>println!</code> 和 <code>vec!</code>，所有的这些宏都会展开成相应的代码，且很可能是长得多的代码。</p>
<p>总之，元编程可以帮我们减少所需编写的代码，也可以一定程度上减少维护的成本，虽然函数复用也有类似的作用，但是宏依然拥有自己独特的优势。</p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>Rust 的函数签名是固定的：定义了两个参数，就必须传入两个参数，多一个少一个都不行。</p>
<p>而宏就可以拥有可变数量的参数，例如可以调用一个参数的 <code>println!(&quot;hello&quot;)</code>，也可以调用两个参数的 <code>println!(&quot;hello &#123;&#125;&quot;, name)</code>。</p>
<h2 id="宏展开"><a href="#宏展开" class="headerlink" title="宏展开"></a>宏展开</h2><p>由于宏会被展开成其它代码，且这个展开过程是发生在编译器对代码进行解释之前。因此，宏可以为指定的类型实现某个特征：先将宏展开成实现特征的代码后，再被编译。</p>
<p>而函数就做不到这一点，因为它直到运行时才能被调用，而特征需要在编译期被实现。</p>
<h2 id="宏的缺点"><a href="#宏的缺点" class="headerlink" title="宏的缺点"></a>宏的缺点</h2><p>相对函数来说，由于宏是基于代码再展开成代码，因此实现相比函数来说会更加复杂，再加上宏的语法更为复杂，最终导致定义宏的代码相当地难读，也难以理解和维护。</p>
<h1 id="声明式宏-macro-rules"><a href="#声明式宏-macro-rules" class="headerlink" title="声明式宏 macro_rules!"></a>声明式宏 macro_rules!</h1><p>在 Rust 中使用最广的就是声明式宏，它们也有一些其它的称呼，例如示例宏( macros by example )、<code>macro_rules!</code> 或干脆直接称呼为宏。</p>
<p>声明式宏允许我们写出类似 match 的代码。宏也是将一个值跟对应的模式进行匹配，且该模式会与特定的代码相关联。但是与 match 不同的是，宏里的值是一段 Rust 源代码(字面量)，模式用于跟这段源代码的结构相比较，一旦匹配，传入宏的那段源代码将被模式关联的代码所替换，最终实现宏展开。值得注意的是，所有的这些都是在编译期发生，并没有运行期的性能损耗。</p>
<h2 id="简化版的-vec"><a href="#简化版的-vec" class="headerlink" title="简化版的 vec!"></a>简化版的 vec!</h2><p>使用 <code>macro_rules!</code> 实现一个简单的 <code>vec!</code>:</p>
<pre><code class="rust">#[macro_export]
macro_rules! vec &#123;
    ( $( $x:expr ),* ) =&gt; &#123;
        &#123;
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        &#125;
    &#125;;
&#125;
</code></pre>
<p><code>#[macro_export]</code> 注释将宏进行了导出，这样其它的包就可以将该宏引入到当前作用域中，然后才能使用。</p>
<p>紧接着，就使用 <code>macro_rules!</code> 进行了宏定义，需要注意的是宏的名称是 <code>vec</code>，而不是 <code>vec!</code>，后者的感叹号只在调用时才需要。</p>
<p><code>vec</code> 的定义结构跟 <code>match</code> 表达式很像，但这里我们只有一个分支，其中包含一个模式 <code>( $( $x:expr ),* )</code>，跟模式相关联的代码就在 <code>=&gt;</code> 之后。一旦模式成功匹配，那这段相关联的代码就会替换传入的源代码。</p>
<p>由于 <code>vec</code> 宏只有一个模式，因此它只能匹配一种源代码，其它类型的都将导致报错，而更复杂的宏往往会拥有更多的分支。</p>
<h2 id="模式解析"><a href="#模式解析" class="headerlink" title="模式解析"></a>模式解析</h2><p>现在来简单理解下 <code>( $( $x:expr ),* )</code> 的含义。</p>
<p>首先使用圆括号 <code>()</code> 将整个宏模式包裹其中。紧随其后的是 <code>$()</code>，跟括号中模式相匹配的值(传入的 Rust 源代码)会被捕获，然后用于代码替换。在这里，模式 <code>$x:expr</code> 会匹配任何 Rust 表达式并给予该模式一个名称：<code>$x</code>。</p>
<p><code>$()</code> 之后的逗号说明在 <code>$()</code> 所匹配的代码的后面会有一个可选的逗号分隔符，紧随逗号之后的 <code>*</code> 说明 <code>*</code> 之前的模式会被匹配零次或任意多次(类似正则表达式)。</p>
<p>当使用 <code>vec![1, 2, 3]</code> 来调用该宏时，<code>$x</code> 模式将被匹配三次，分别是 <code>1</code>、<code>2</code>、<code>3</code>。</p>
<p>总结一下：</p>
<ol>
<li><code>$()</code> 中包含的是模式 <code>$x:expr</code>，该模式中的 <code>expr</code> 表示会匹配任何 Rust 表达式，并给予该模式一个名称 <code>$x</code></li>
<li>因此 <code>$x</code> 模式可以跟整数 <code>1</code> 进行匹配，也可以跟字符串 <code>&quot;hello&quot;</code> 进行匹配: <code>vec![&quot;hello&quot;, &quot;world&quot;]</code></li>
<li><code>$()</code> 之后的逗号，意味着 <code>1</code> 和 <code>2</code> 之间可以使用逗号进行分割，也意味着 <code>3</code> 既可以没有逗号，也可以有逗号：<code>vec![1, 2, 3,]</code></li>
<li><code>*</code> 说明之前的模式可以出现零次也可以任意次，这里出现了三次</li>
</ol>
<p>接下来再来看看与模式相关联、在 <code>=&gt;</code> 之后的代码：</p>
<pre><code class="rust">&#123;
    &#123;
        let mut temp_vec = Vec::new();
        $(
            temp_vec.push($x);
        )*
        temp_vec
    &#125;
&#125;;
</code></pre>
<p>这里就比较好理解了，<code>$()</code> 中的 <code>temp_vec.push()</code> 将根据模式匹配的次数生成对应的代码，当调用 <code>vec![1, 2, 3]</code> 时，下面这段生成的代码将替代传入的源代码，也就是替代 <code>vec![1, 2, 3]</code>:</p>
<pre><code class="rust">&#123;
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
&#125;
</code></pre>
<h1 id="用过程宏为属性标记生成代码"><a href="#用过程宏为属性标记生成代码" class="headerlink" title="用过程宏为属性标记生成代码"></a>用过程宏为属性标记生成代码</h1><p>第二种常用的宏就是过程宏 ( <em>procedural macros</em> )，从形式上来看，过程宏跟函数较为相像，但过程宏是使用源代码作为输入参数，基于代码进行一系列操作后，再输出一段全新的代码。</p>
<p>注意，过程宏中的 derive 宏输出的代码并不会替换之前的代码，这一点与声明宏有很大的不同！</p>
<p>当创建过程宏时，它的定义必须要放入一个独立的包中，且包的类型也是特殊的，这么做的原因相当复杂，只要知道这种限制在未来可能会有所改变即可。</p>
<blockquote>
<p>事实上，根据<a target="_blank" rel="noopener" href="https://www.reddit.com/r/rust/comments/t1oa1e/what_are_the_complex_technical_reasons_why/">这个说法</a>，过程宏放入独立包的原因在于它必须先被编译后才能使用，如果过程宏和使用它的代码在一个包，就必须先单独对过程宏的代码进行编译，然后再对我们的代码进行编译，但悲剧的是 Rust 的编译单元是包，因此你无法做到这一点。</p>
</blockquote>
<h2 id="自定义-derive-过程宏"><a href="#自定义-derive-过程宏" class="headerlink" title="自定义 derive 过程宏"></a>自定义 derive 过程宏</h2><p>假设我们有一个特征 <code>HelloMacro</code>，现在有两种方式让用户使用它：</p>
<ul>
<li>为每个类型手动实现该特征</li>
<li>使用过程宏来统一实现该特征，这样用户只需要对类型进行标记即可：<code>#[derive(HelloMacro)]</code></li>
</ul>
<p>如果不同的类型都可以使用同样的默认特征实现，那么使用过程宏的方式可以减少很多代码实现：</p>
<pre><code class="rust">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Sunfei;

#[derive(HelloMacro)]
struct Sunface;

fn main() &#123;
    Sunfei::hello_macro();
    Sunface::hello_macro();
&#125;
</code></pre>
<p>在使用宏之前，需要创建一个新的工程：</p>
<pre><code class="sh">$ cargo new hello_macro
$ cd hello_macro/
$ touch src/lib.rs
</code></pre>
<p>之后在 <code>src/lib.rs</code> 中定义过程宏所需的 <code>HelloMacro</code> 特征和其关联函数:</p>
<pre><code class="rust">pub trait HelloMacro &#123;
    fn hello_macro();
&#125;
</code></pre>
<p>然后需要创建过程宏，对于 hello_macro 宏而言，包名就应该是 hello_macro_derive。在之前创建的 hello_macro 项目根目录下，运行如下命令，创建一个单独的 lib 包:</p>
<pre><code class="sh">cargo new hello_macro_derive --lib
</code></pre>
<p>至此， hello_macro 项目的目录结构如下：</p>
<pre><code>hello_macro
├── Cargo.toml
├── src
│   ├── main.rs
│   └── lib.rs
└── hello_macro_derive
    ├── Cargo.toml
    ├── src
        └── lib.rs
</code></pre>
<p>但是直接这样还是无法使用，还需要我们手动导入模块，修改 <code>hello_macro/Cargo.toml</code> 文件添加以下内容:</p>
<pre><code class="toml">[dependencies]
hello_macro_derive = &#123; path = &quot;../hello_macro/hello_macro_derive&quot; &#125;
# 也可以使用下面的相对路径
# hello_macro_derive = &#123; path = &quot;./hello_macro_derive&quot; &#125;
</code></pre>
<p>这里需要用到一个 cargo-expand 的工具，用来调试宏，可以通过下面的命令安装:</p>
<pre><code class="sh">cargo install cargo-expand
</code></pre>
<h3 id="定义过程宏"><a href="#定义过程宏" class="headerlink" title="定义过程宏"></a>定义过程宏</h3><p>首先，在 hello_macro_derive&#x2F;Cargo.toml 文件中添加以下内容：</p>
<pre><code class="rust">[lib]
proc-macro = true

[dependencies]
syn = &quot;1.0&quot;
quote = &quot;1.0&quot;
</code></pre>
<p>其中 <code>syn</code> 和 <code>quote</code> 依赖包都是定义过程宏所必需的，同时，还需要在 <code>[lib]</code> 中将过程宏的开关开启 : <code>proc-macro = true</code>。</p>
<p>其次，在 <code>hello_macro_derive/src/lib.rs</code> 中添加如下代码：</p>
<pre><code class="rust">extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn;
use syn::DeriveInput;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream &#123;
    // 基于 input 构建 AST 语法树
    let ast:DeriveInput = syn::parse(input).unwrap();

    // 构建特征实现代码
    impl_hello_macro(&amp;ast)
&#125;
</code></pre>
<p>首先有一点，对于绝大多数过程宏而言，这段代码往往只在 <code>impl_hello_macro(&amp;ast)</code> 中的实现有所区别，对于其它部分基本都是一致的，如包的引入、宏函数的签名、语法树构建等。</p>
<p><code>proc_macro</code> 包是 Rust 自带的，因此无需在 <code>Cargo.toml</code> 中引入依赖，它包含了相关的编译器 API，可以用于读取和操作 Rust 源代码。</p>
<p>由于我们为 <code>hello_macro_derive</code> 函数标记了 <code>#[proc_macro_derive(HelloMacro)]</code>，当用户使用 <code>#[derive(HelloMacro)]</code> 标记了他的类型后，<code>hello_macro_derive</code> 函数就将被调用。这里的秘诀就是特征名 <code>HelloMacro</code>，它就像一座桥梁，将用户的类型和过程宏联系在一起。</p>
<p><code>syn</code> 将字符串形式的 Rust 代码解析为一个 AST 树的数据结构，该数据结构可以在随后的 <code>impl_hello_macro</code> 函数中进行操作。最后，操作的结果又会被 <code>quote</code> 包转换回 Rust 代码。这些包非常关键，可以帮我们节省大量的精力，否则你需要自己去编写支持代码解析和还原的解析器，这可不是一件简单的任务！</p>
<p><code>derive</code> 过程宏只能用在 <code>struct/enum/union</code> 上，多数用在结构体上，我们先来看一下一个结构体由哪些部分组成:</p>
<pre><code class="rust">// vis，可视范围             ident，标识符     generic，范型    fields: 结构体的字段
pub              struct    User            &lt;&#39;a, T&gt;          &#123;

// vis   ident   type
   pub   name:   &amp;&#39;a T,

&#125;
</code></pre>
<p>其中 <code>type</code> 还可以细分，具体请阅读 <code>syn</code> 文档或源码.</p>
<p><code>syn::parse</code> 调用会返回一个 <code>DeriveInput</code> 结构体来代表解析后的 Rust 代码:</p>
<pre><code class="rust">DeriveInput &#123;
    // --snip--
    vis: Visibility,
    ident: Ident &#123;
        ident: &quot;Sunfei&quot;,
        span: #0 bytes(95..103)
    &#125;,
    generics: Generics,
    // Data是一个枚举，分别是DataStruct，DataEnum，DataUnion，这里以 DataStruct 为例
    data: Data(
        DataStruct &#123;
            struct_token: Struct,
            fields: Fields,
            semi_token: Some(
                Semi
            )
        &#125;
    )
&#125;
</code></pre>
<p>以上就是源代码 <code>struct Sunfei</code>; 解析后的结果，里面有几点值得注意:</p>
<ul>
<li><code>fields: Fields</code> 是一个枚举类型，<code>Fields::Named</code>, <code>Fields::Unnamed</code>, <code>Fields::Unit</code> 分别表示结构体中的显式命名字段（如例子所示），元组或元组变体中的匿名字段(例如<code>Some(T)</code>)，单元类型或单元变体字段（例如<code>None</code> ）。</li>
<li><code>ident: &quot;Sunfei&quot;</code> 说明类型名称为 <code>Sunfei</code>， <code>ident</code> 是标识符 <code>identifier</code> 的简写</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://docs.rs/syn/1.0/syn/struct.DeriveInput.html">syn文档</a>。</p>
<p>下面来看看如何构建特征实现的代码，也是过程宏的核心目标:</p>
<pre><code class="rust">fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream &#123;
    let name = &amp;ast.ident;
    let gen = quote! &#123;
        impl HelloMacro for #name &#123;
            fn hello_macro() &#123;
                println!(&quot;Hello, Macro! My name is &#123;&#125;!&quot;, stringify!(#name));
            &#125;
        &#125;
    &#125;;
    gen.into()
&#125;
</code></pre>
<p>首先，将结构体的名称赋予给 <code>name</code>，也就是 <code>name</code> 中会包含一个字段，它的值是字符串 <code>&quot;Sunfei&quot;</code>。</p>
<p>其次，使用 <code>quote!</code> 可以定义我们想要返回的 Rust 代码。由于编译器需要的内容和 <code>quote!</code> 直接返回的不一样，因此还需要使用 <code>.into</code> 方法其转换为 <code>TokenStream</code>。</p>
<p>大家注意到 <code>#name</code> 的使用了吗？这也是 <code>quote!</code> 提供的功能之一，如果想要深入了解 <code>quote</code>，可以看看<a target="_blank" rel="noopener" href="https://docs.rs/quote">官方文档</a>。</p>
<p>其中 <code>stringify!</code> 是 Rust 提供的内置宏，可以将一个表达式(例如 1 + 2)在编译期转换成一个字符串字面值<code>(&quot;1 + 2&quot;)</code>，该字面量会直接打包进编译出的二进制文件中，具有 <code>&#39;static</code> 生命周期。而 <code>format!</code> 宏会对表达式进行求值，最终结果是一个 <code>String</code> 类型。在这里使用 <code>stringify!</code> 有两个好处:</p>
<ul>
<li><code>#name</code> 可能是一个表达式，我们需要它的字面值形式</li>
<li>可以减少一次 String 带来的内存分配</li>
</ul>
<p>在运行之前，可以先用 <code>expand</code> 展开宏，观察是否有错误或符合预期:</p>
<pre><code class="sh">cargo expand --bin hello_macro
</code></pre>
<p>运行后会显示编译后的代码。</p>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 IceOfSummerの博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;<a target="_blank" rel="noopener" href="https://github.com/IceOfSummer">IceOfSummer</a>
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/IceOfSummer/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        
<script
    src="https://giscus.app/client.js"
    data-repo="IceOfSummer/iceofsummer.github.io"
    data-repo-id="R_kgDOJFU7OQ"
    data-category="Announcements"
    data-category-id="DIC_kwDOJFU7Oc4CUyC7"
    data-mapping="title"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin
    async
></script>





        
    </body>
</html>
