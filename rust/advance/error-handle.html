
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>错误处理 | IceOfSummerの博客</title>
        <meta name="author" content="IceOfSummer" />
        <meta name="description" content="后面一辈子的博客都在这了！" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="https://selfb.asia/static/particlex/static/fonts.min.css" />
<script>
  const mixins = {};
  const h = (arg1, arg2, arg3) => {
    if (arg2.attrs) {
      Object.assign(arg2, arg2.attrs)
      Reflect.deleteProperty(arg2, 'attrs')
    }
    if (arg2.on) {
      Object.keys(arg2.on).forEach(key => {
        const head = key.charAt(0).toUpperCase()
        arg2['on' + head  + key.substring(1)] = arg2.on[key]
      })
      Reflect.deleteProperty(arg2, 'on')
    }
    return Vue.h(arg1, arg2, arg3)
  }
</script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

  <script src="/js/lib/toc.js"></script>



  <script src="/js/lib/lazy-load-support.js"></script>


    <meta name="generator" content="Hexo 7.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存&ensp;浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            </transition>
            <transition name="into">
            <div id="main" v-show="!loading">
                <nav id="menu" ref="menu">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>ICEOFSUMMERの博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" v-show="showMenu" @click="showMenu = !showMenu"></div>
        <div class="title" @click="showMenu = !showMenu">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ICEOFSUMMERの博客</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenu">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

                <div class="article">
    <div>
        <h1>错误处理</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/6/2
        </span>
        
        <span class="category">
            <a href="/2023/12/04/rust/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Rust
            </a>
        </span>
        
        
    </div>
    
    <toc-component></toc-component>
    <div class="content" v-pre id="main-content">
        <h1 id="组合器"><a href="#组合器" class="headerlink" title="组合器"></a>组合器</h1><p>在 Rust 中，组合器用于对返回结果的类型进行变换：例如使用 <code>ok_or</code> 将一个 <code>Option</code> 类型转换成 <code>Result</code> 类型。</p>
<h2 id="or-和-and"><a href="#or-和-and" class="headerlink" title="or() 和 and()"></a>or() 和 and()</h2><p>跟布尔关系的与&#x2F;或很像，这两个方法会对两个表达式做逻辑组合，最终返回 <code>Option</code> &#x2F; <code>Result</code>。</p>
<ul>
<li><code>or()</code>，表达式按照顺序求值，若任何一个表达式的结果是 <code>Some</code> 或 <code>Ok</code>，则该值会立刻返回，否则返回 <code>or</code> 中指定的参数。<pre><code class="rust">let some1 = Some(&quot;some1&quot;);
let some2 = Some(&quot;some2&quot;);
let none: Option&lt;&amp;str&gt; = None;

assert_eq!(some1.or(some2), some1); // Some1 or Some2 = Some1
assert_eq!(some1.or(none), some1);  // Some or None = Some
assert_eq!(none.or(some1), some1);  // None or Some = Some
assert_eq!(none.or(none), none);    // None1 or None2 = None2
</code></pre>
</li>
<li><code>and()</code>，如果自身为 <code>None</code> 或者 <code>Err</code> 则返回自身，否则返回 <code>and()</code> 中的参数<pre><code class="rust">let some1 = Some(&quot;some1&quot;);
let some2 = Some(&quot;some2&quot;);
let none: Option&lt;&amp;str&gt; = None;

assert_eq!(some1.and(some2), some2); // Some1 and Some2 = Some2
assert_eq!(some1.and(none), none);   // Some and None = None
assert_eq!(none.and(some1), none);   // None and Some = None
assert_eq!(none.and(none), none);    // None1 and None2 = None1
</code></pre>
</li>
</ul>
<p>对于 <code>Options</code>， 还有 <code>xor</code> 可用，它会在仅有一个值为 <code>&#39;true&#39;</code> 时，返回该值。</p>
<p>实际可以把 <code>Some</code> 和 <code>Ok</code> 看做 <code>true</code>，<code>None</code> 和 <code>Err</code> 看做 <code>false</code>:</p>
<p>当进行逻辑判断时，最后一次的成功判断，则为返回的值。</p>
<p>例如 <code>Some1 or Some2</code>，在判断 <code>Some1</code> 时，就可以知道整个表达式都是 <code>true</code> 了，因此此时 <code>Some1</code> 为返回的值。</p>
<p>再例如 <code>Some1 and Some2</code>，此时需要比较两个值，最后比较的是 <code>Some2</code> 因此 <code>Some2</code> 为返回的值。</p>
<h2 id="or-else-和-and-then"><a href="#or-else-和-and-then" class="headerlink" title="or_else() 和 and_then()"></a>or_else() 和 and_then()</h2><p>它们跟 <code>or()</code> 和 <code>and()</code> 类似，唯一的区别在于，它们的第二个表达式是一个闭包。</p>
<pre><code class="rust">fn main() &#123;
    // or_else with Option
    let some1 = Some(&quot;some1&quot;);
    let some2 = Some(&quot;some2&quot;);
    let fn_some2 = || Some(&quot;some2&quot;); // 类似于: let fn_some = || -&gt; Option&lt;&amp;str&gt; &#123; Some(&quot;some2&quot;) &#125;;

    let none: Option&lt;&amp;str&gt; = None;
    let fn_none = || None;

    assert_eq!(some1.or_else(fn_some2), some1);  // Some1 or_else Some2 = Some1
    assert_eq!(some1.or_else(fn_none), some1);  // Some or_else None = Some
    assert_eq!(none.or_else(fn_some2), some2);   // None or_else Some = Some
    assert_eq!(none.or_else(fn_none), None); // None1 or_else None2 = None2
&#125;
</code></pre>
<p><code>and_then()</code> 可以获取前一个表达式的值： </p>
<pre><code class="rust">fn main() &#123;
    // and_then with Option
    let some1 = Some(&quot;some1&quot;);
    let some2 = Some(&quot;some2&quot;);
    let fn_some2 = |_| Some(&quot;some2&quot;); // 类似于: let fn_some = |_| -&gt; Option&lt;&amp;str&gt; &#123; Some(&quot;some2&quot;) &#125;;

    let n: Option&lt;&amp;str&gt; = None;
    let fn_none = |_| None;

    assert_eq!(some1.and_then(fn_some2), some2); // Some1 and_then Some2 = Some2
    assert_eq!(some1.and_then(fn_none), n);  // Some and_then None = None
    assert_eq!(n.and_then(fn_some2), n);   // None and_then Some = None
    assert_eq!(n.and_then(fn_none), n);   // None1 and_then None2 = None1
&#125;
</code></pre>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p><code>filter</code> 用于对 <code>Option</code> 进行过滤，当 <code>Option</code> 值为 <code>None</code> 时，直接返回，否则调用闭包函数进行过滤，当闭包函数返回 <code>true</code> 时，才返回 <code>Some</code> 中的值，否则返回 <code>None</code>。</p>
<pre><code class="rust">fn main() &#123;
    let s1 = Some(3);
    let s2 = Some(6);
    let n = None;

    let fn_is_even = |x: &amp;i8| x % 2 == 0;

    assert_eq!(s1.filter(fn_is_even), n);  // Some(3) -&gt; 3 is not even -&gt; None
    assert_eq!(s2.filter(fn_is_even), s2); // Some(6) -&gt; 6 is even -&gt; Some(6)
    assert_eq!(n.filter(fn_is_even), n);   // None -&gt; no value -&gt; None
&#125;
</code></pre>
<h2 id="map-和-map-err"><a href="#map-和-map-err" class="headerlink" title="map() 和 map_err()"></a>map() 和 map_err()</h2><p><code>map</code> 可以将 <code>Some</code> 或 <code>Ok</code> 中的值映射为另一个：</p>
<pre><code class="rust">fn main() &#123;
    let s1 = Some(&quot;abcde&quot;);
    let s2 = Some(5);

    let n1: Option&lt;&amp;str&gt; = None;
    let n2: Option&lt;usize&gt; = None;

    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);
    let o2: Result&lt;usize, &amp;str&gt; = Ok(5);

    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;abcde&quot;);
    let e2: Result&lt;usize, &amp;str&gt; = Err(&quot;abcde&quot;);

    let fn_character_count = |s: &amp;str| s.chars().count();

    assert_eq!(s1.map(fn_character_count), s2); // Some1 map = Some2
    assert_eq!(n1.map(fn_character_count), n2); // None1 map = None2

    assert_eq!(o1.map(fn_character_count), o2); // Ok1 map = Ok2
    assert_eq!(e1.map(fn_character_count), e2); // Err1 map = Err2
&#125;
</code></pre>
<p><code>map_err</code> 则是将 <code>Err</code> 中的值转换成另外一个，在面对 <code>Ok</code> 时将直接返回：</p>
<pre><code class="rust">fn main() &#123;
    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);
    let o2: Result&lt;&amp;str, isize&gt; = Ok(&quot;abcde&quot;);

    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;404&quot;);
    let e2: Result&lt;&amp;str, isize&gt; = Err(404);

    let fn_character_count = |s: &amp;str| -&gt; isize &#123; s.parse().unwrap() &#125;; // 该函数返回一个 isize

    assert_eq!(o1.map_err(fn_character_count), o2); // Ok1 map = Ok2
    assert_eq!(e1.map_err(fn_character_count), e2); // Err1 map = Err2
&#125;
</code></pre>
<h2 id="map-or-和-map-or-else"><a href="#map-or-和-map-or-else" class="headerlink" title="map_or() 和 map_or_else()"></a>map_or() 和 map_or_else()</h2><p><code>map_or</code> 在 <code>map</code> 的基础上提供了一个默认值:</p>
<pre><code class="rust">fn main() &#123;
    const V_DEFAULT: u32 = 1;

    let s: Result&lt;u32, ()&gt; = Ok(10);
    let n: Option&lt;u32&gt; = None;
    let fn_closure = |v: u32| v + 2;

    assert_eq!(s.map_or(V_DEFAULT, fn_closure), 12);
    assert_eq!(n.map_or(V_DEFAULT, fn_closure), V_DEFAULT);
&#125;
</code></pre>
<p>当 <code>map_or</code> 处理 <code>None</code> 时，将会返回第一个参数作为默认值。</p>
<p><code>map_or_else</code> 与 <code>map_or</code> 类似，但是它是通过一个闭包来提供默认值:</p>
<pre><code class="rust">fn main() &#123;
    let s = Some(10);
    let n: Option&lt;i8&gt; = None;

    let fn_closure = |v: i8| v + 2;
    let fn_default = || 1;

    assert_eq!(s.map_or_else(fn_default, fn_closure), 12);
    assert_eq!(n.map_or_else(fn_default, fn_closure), 1);

    let o = Ok(10);
    let e = Err(5);
    let fn_default_for_result = |v: i8| v + 1; // 闭包可以对 Err 中的值进行处理，并返回一个新值

    assert_eq!(o.map_or_else(fn_default_for_result, fn_closure), 12);
    assert_eq!(e.map_or_else(fn_default_for_result, fn_closure), 6);
&#125;
</code></pre>
<h2 id="ok-or-and-ok-or-else"><a href="#ok-or-and-ok-or-else" class="headerlink" title="ok_or() and ok_or_else()"></a>ok_or() and ok_or_else()</h2><p>这两个组合器可以将 <code>Some(v)</code> 转换成 <code>Ok(v)</code>，<code>None</code> 转化为 <code>Err(err)</code>:</p>
<pre><code class="rust">fn main() &#123;
    const ERR_DEFAULT: &amp;str = &quot;error message&quot;;

    let s = Some(&quot;abcde&quot;);
    let n: Option&lt;&amp;str&gt; = None;

    let o: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);
    let e: Result&lt;&amp;str, &amp;str&gt; = Err(ERR_DEFAULT);

    assert_eq!(s.ok_or(ERR_DEFAULT), o); // Some(T) -&gt; Ok(T)
    assert_eq!(n.ok_or(ERR_DEFAULT), e); // None -&gt; Err(default)
&#125;
</code></pre>
<p><code>ok_or_else</code> 则是提供了懒加载错误的方式：</p>
<pre><code class="rust">fn main() &#123;
    let s = Some(&quot;abcde&quot;);
    let n: Option&lt;&amp;str&gt; = None;
    let fn_err_message = || &quot;error message&quot;;

    let o: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);
    let e: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error message&quot;);

    assert_eq!(s.ok_or_else(fn_err_message), o); // Some(T) -&gt; Ok(T)
    assert_eq!(n.ok_or_else(fn_err_message), e); // None -&gt; Err(default)
&#125;
</code></pre>
<h1 id="归一化不同的错误类型"><a href="#归一化不同的错误类型" class="headerlink" title="归一化不同的错误类型"></a>归一化不同的错误类型</h1><h2 id="自定义错误类型"><a href="#自定义错误类型" class="headerlink" title="自定义错误类型"></a>自定义错误类型</h2><p>为了帮助我们更好的定义错误，Rust 在标准库中提供了一些可复用的特征，例如 <code>std::error::Error</code> 特征：</p>
<pre><code class="rust">use std::fmt::&#123;Debug, Display&#125;;

pub trait Error: Debug + Display &#123;
    fn source(&amp;self) -&gt; Option&lt;&amp;(Error + &#39;static)&gt; &#123; ... &#125;
&#125;
</code></pre>
<p>虽然 <code>Result</code> 中<strong>并没有强制要求</strong> <code>Err</code> 的参数实现 <code>Error</code> 特征，但是对于一个错误来说，实现 <code>Error</code> 特征可以统一接口，为错误类型提供了一个标准化的接口，使得不同的错误类型可以以一致的方式被处理和操作。</p>
<p>要想实现 <code>Error</code> 特征，则必须实现 <code>Debug</code> 和 <code>Display</code> 特征。</p>
<p><code>Error::source()</code> 方法一般是可选的，如果不实现，默认返回 <code>None</code>，这个方法一般用于返回内部错误，例如这个错误可能是由多个其它错误，或者某个子错误造成的，则可以通过该方法获取更原始的错误信息，进而方便问题的定位。</p>
<h2 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h2><p>在实际项目中，一个函数可能会返回多种错误类型，但是正常情况下只能够指定一种：</p>
<pre><code class="rust">use std::fs::read_to_string;

fn main() -&gt; Result&lt;(), std::io::Error&gt; &#123;
  let html = render()?;
  println!(&quot;&#123;&#125;&quot;, html);
  Ok(())
&#125;

fn render() -&gt; Result&lt;String, std::io::Error&gt; &#123;
  let file = std::env::var(&quot;MARKDOWN&quot;)?;
  let source = read_to_string(file)?;
  Ok(source)
&#125;
</code></pre>
<p>编译报错：</p>
<pre><code class="log">error[E0277]: `?` couldn&#39;t convert the error to `std::io::Error`
  --&gt; src\main.rs:10:41
   |
9  | fn render() -&gt; Result&lt;String, std::io::Error&gt; &#123;
   |                ------------------------------ expected `std::io::Error` because of this
10 |     let file = std::env::var(&quot;MARKDOWN&quot;)?;
   |                                         ^ the trait `From&lt;VarError&gt;` is not implemented for `std::io::Error`
   |
</code></pre>
<p>上面的代码会报错，原因在于 <code>render</code> 函数中的两个 <code>?</code> 返回的实际上是不同的错误：<code>env::var()</code> 返回的是 <code>std::env::VarError</code>，而 <code>read_to_string</code> 返回的是 <code>std::io::Error</code>。</p>
<p>为了满足 <code>render</code> 函数的签名，就需要将 <code>env::VarError</code> 和 <code>io::Error</code> 归一化为同一种错误类型。</p>
<h3 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box<dyn Error></h3><p>正常情况下，所有的错误类型都应该实现 <code>Error</code> 特征，此时我们就可以直接使用特征对象来处理所有的错误：</p>
<pre><code class="rust">use std::fs::read_to_string;
use std::error::Error;
fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; &#123;
  let html = render()?;
  println!(&quot;&#123;&#125;&quot;, html);
  Ok(())
&#125;

fn render() -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; &#123;
  let file = std::env::var(&quot;MARKDOWN&quot;)?;
  let source = read_to_string(file)?;
  Ok(source)
&#125;
</code></pre>
<p>但是一旦 <code>Result&lt;T, E&gt;</code> 中的 <code>E</code> 没有实现 <code>Error</code> 特征，这个方法就不管用了。</p>
<h3 id="自定义错误类型-1"><a href="#自定义错误类型-1" class="headerlink" title="自定义错误类型"></a>自定义错误类型</h3><p>自定义错误类型麻烦归麻烦，但是它非常灵活，因此也不具有上面的类似限制:</p>
<pre><code class="rust">use std::fs::read_to_string;

fn main() -&gt; Result&lt;(), MyError&gt; &#123;
  let html = render()?;
  println!(&quot;&#123;&#125;&quot;, html);
  Ok(())
&#125;

fn render() -&gt; Result&lt;String, MyError&gt; &#123;
  let file = std::env::var(&quot;MARKDOWN&quot;)?;
  let source = read_to_string(file)?;
  Ok(source)
&#125;

#[derive(Debug)]
enum MyError &#123;
  EnvironmentVariableNotFound,
  IOError(std::io::Error),
&#125;

impl From&lt;std::env::VarError&gt; for MyError &#123;
  fn from(_: std::env::VarError) -&gt; Self &#123;
    Self::EnvironmentVariableNotFound
  &#125;
&#125;

impl From&lt;std::io::Error&gt; for MyError &#123;
  fn from(value: std::io::Error) -&gt; Self &#123;
    Self::IOError(value)
  &#125;
&#125;

impl std::error::Error for MyError &#123;&#125;

impl std::fmt::Display for MyError &#123;
  fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result &#123;
    match self &#123;
      MyError::EnvironmentVariableNotFound =&gt; write!(f, &quot;Environment variable not found&quot;),
      MyError::IOError(err) =&gt; write!(f, &quot;IO Error: &#123;&#125;&quot;, err.to_string()),
    &#125;
  &#125;
&#125;
</code></pre>
<p>上面代码中有一行值得注意：<code>impl std::error::Error for MyError &#123;&#125;</code> ，只有为自定义错误类型实现 <code>Error</code> 特征后，才能转换成相应的特征对象。</p>
<h2 id="简化错误处理"><a href="#简化错误处理" class="headerlink" title="简化错误处理"></a>简化错误处理</h2><h3 id="thiserror"><a href="#thiserror" class="headerlink" title="thiserror"></a>thiserror</h3><p>自定义错误类型很灵活，但是它太啰嗦了，每次都需要编写一堆代码。</p>
<p>好在使用 <a target="_blank" rel="noopener" href="https://github.com/dtolnay/thiserror">thiserror</a> 可以帮助我们简化错误的声明：</p>
<pre><code class="rust">use std::fs::read_to_string;

fn main() -&gt; Result&lt;(), MyError&gt; &#123;
  let html = render()?;
  println!(&quot;&#123;&#125;&quot;, html);
  Ok(())
&#125;

fn render() -&gt; Result&lt;String, MyError&gt; &#123;
  let file = std::env::var(&quot;MARKDOWN&quot;)?;
  let source = read_to_string(file)?;
  Ok(source)
&#125;

#[derive(thiserror::Error, Debug)]
enum MyError &#123;
  #[error(&quot;Environment variable not found&quot;)]
  EnvironmentVariableNotFound(#[from] std::env::VarError),
  #[error(transparent)]
  IOError(#[from] std::io::Error),
&#125;
</code></pre>
<p><code>#[error]</code> 用于定于 <code>Display</code> 中具体的打印信息，常用格式如下：</p>
<ul>
<li><code>#[error(&quot;&#123;var&#125;&quot;)]</code> ⟶ <code>write!(&quot;&#123;&#125;&quot;, self.var)</code></li>
<li><code>#[error(&quot;&#123;0&#125;&quot;)]</code> ⟶ <code>write!(&quot;&#123;&#125;&quot;, self.0)</code></li>
<li><code>#[error(&quot;&#123;var:?&#125;&quot;)]</code> ⟶ <code>write!(&quot;&#123;:?&#125;&quot;, self.var)</code></li>
<li><code>#[error(&quot;&#123;0:?&#125;&quot;)]</code> ⟶ <code>write!(&quot;&#123;:?&#125;&quot;, self.0)</code></li>
</ul>
<p><code>#[error(transparent)]</code> 则是直接使用源错误的 <code>Display</code> 方法。</p>
<p>更多用法可以在 <code>Github</code> 仓库页面查看。</p>
<h3 id="anyhow"><a href="#anyhow" class="headerlink" title="anyhow"></a>anyhow</h3><p><a target="_blank" rel="noopener" href="https://github.com/dtolnay/anyhow">anyhow</a> 在你并不关心函数错误的返回类型时很管用。</p>
<p>例如开发一款应用时，在业务逻辑中有些错误可能并不想直接处理，而是直接抛出去给上层，交给统一的错误处理器来处理。</p>
<pre><code class="rust">use std::fs::read_to_string;

use anyhow::Result;

fn main() -&gt; Result&lt;()&gt; &#123;
    let html = render()?;
    println!(&quot;&#123;&#125;&quot;, html);
    Ok(())
&#125;

fn render() -&gt; Result&lt;String&gt; &#123;
    let file = std::env::var(&quot;MARKDOWN&quot;)?;
    let source = read_to_string(file)?;
    Ok(source)
&#125;
</code></pre>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 IceOfSummerの博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;<a target="_blank" rel="noopener" href="https://github.com/IceOfSummer">IceOfSummer</a>
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/IceOfSummer/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        
<script
    src="https://giscus.app/client.js"
    data-repo="IceOfSummer/iceofsummer.github.io"
    data-repo-id="R_kgDOJFU7OQ"
    data-category="Announcements"
    data-category-id="DIC_kwDOJFU7Oc4CUyC7"
    data-mapping="title"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin
    async
></script>





        
    </body>
</html>
