
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>多线程并发编程 Part 2 | IceOfSummerの博客</title>
        <meta name="author" content="IceOfSummer" />
        <meta name="description" content="后面一辈子的博客都在这了！" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <script src="https://selfb.asia/static/lib/vue-3.2.47.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="https://selfb.asia/static/particlex/static/fonts.min.css" />
<script>
  const mixins = {};
  const h = (arg1, arg2, arg3) => {
    if (arg2.attrs) {
      Object.assign(arg2, arg2.attrs)
      Reflect.deleteProperty(arg2, 'attrs')
    }
    if (arg2.on) {
      Object.keys(arg2.on).forEach(key => {
        const head = key.charAt(0).toUpperCase()
        arg2['on' + head  + key.substring(1)] = arg2.on[key]
      })
      Reflect.deleteProperty(arg2, 'on')
    }
    return Vue.h(arg1, arg2, arg3)
  }
</script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://selfb.asia/static/lib/highlight-11.7.0.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

  <script src="/js/lib/toc.js"></script>



  <script src="/js/lib/lazy-load-support.js"></script>


    <meta name="generator" content="Hexo 7.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存&ensp;浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            </transition>
            <transition name="into">
            <div id="main" v-show="!loading">
                <nav id="menu" ref="menu">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>ICEOFSUMMERの博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" v-show="showMenu" @click="showMenu = !showMenu"></div>
        <div class="title" @click="showMenu = !showMenu">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ICEOFSUMMERの博客</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenu">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

                <div class="article">
    <div>
        <h1>多线程并发编程 Part 2</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/6/1
        </span>
        
        <span class="category">
            <a href="/2023/12/04/rust/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Rust
            </a>
        </span>
        
        
    </div>
    
    <toc-component></toc-component>
    <div class="content" v-pre id="main-content">
        <h1 id="线程同步：Atomic-原子类型与内存顺序"><a href="#线程同步：Atomic-原子类型与内存顺序" class="headerlink" title="线程同步：Atomic 原子类型与内存顺序"></a>线程同步：Atomic 原子类型与内存顺序</h1><p><code>Mutex</code>用起来简单，但是无法并发读，<code>RwLock</code>可以并发读，但是使用场景较为受限且性能不够高…</p>
<p>从 Rust1.34 版本后，就正式支持原子类型。原子指的是一系列不可被 CPU 上下文交换的机器指令，这些指令组合在一起就形成了原子操作。在多核 CPU 下，当某个 CPU 核心开始运行原子操作时，会先暂停其它 CPU 内核对内存的操作，以保证原子操作不会被其它 CPU 内核所干扰。</p>
<p>由于原子操作是通过指令提供的支持，因此它的性能相比锁和消息传递会好很多。相比较于锁而言，原子类型不需要开发者处理加锁和释放锁的问题，同时支持修改，读取等操作，还具备较高的并发性能，几乎所有的语言都支持原子类型。</p>
<p>可以看出原子类型是无锁类型，但是无锁不代表无需等待，因为原子类型内部使用了 <code>CAS</code> 循环，当大量的冲突发生时，该等待还是得等待！但是总归比锁要好。</p>
<h2 id="使用-Atomic-作为全局变量"><a href="#使用-Atomic-作为全局变量" class="headerlink" title="使用 Atomic 作为全局变量"></a>使用 Atomic 作为全局变量</h2><p>原子类型的一个常用场景，就是作为全局变量来使用:</p>
<pre><code class="rust">use std::ops::Sub;
use std::sync::atomic::&#123;AtomicU64, Ordering&#125;;
use std::thread::&#123;self, JoinHandle&#125;;
use std::time::Instant;

const N_TIMES: u64 = 10000000;
const N_THREADS: usize = 10;

static R: AtomicU64 = AtomicU64::new(0);

fn add_n_times(n: u64) -&gt; JoinHandle&lt;()&gt; &#123;
    thread::spawn(move || &#123;
        for _ in 0..n &#123;
            R.fetch_add(1, Ordering::Relaxed);
        &#125;
    &#125;)
&#125;

fn main() &#123;
    let s = Instant::now();
    let mut threads = Vec::with_capacity(N_THREADS);

    for _ in 0..N_THREADS &#123;
        threads.push(add_n_times(N_TIMES));
    &#125;

    for thread in threads &#123;
        thread.join().unwrap();
    &#125;

    assert_eq!(N_TIMES * N_THREADS as u64, R.load(Ordering::Relaxed));

    println!(&quot;&#123;:?&#125;&quot;,Instant::now().sub(s));
&#125;
</code></pre>
<p>以上代码启动了数个线程，每个线程都在疯狂对全局变量进行加 1 操作, 最后将它与线程数 * 加1次数进行比较，如果发生了因为多个线程同时修改导致了脏数据，那么这两个必将不相等。好在，它没有让我们失望，不仅快速的完成了任务，而且保证了 100%的并发安全性。</p>
<h2 id="内存顺序"><a href="#内存顺序" class="headerlink" title="内存顺序"></a>内存顺序</h2><p>内存顺序是指 CPU 在访问内存时的顺序，该顺序可能受以下因素的影响：</p>
<ul>
<li>代码中的先后顺序</li>
<li>编译器优化导致在编译阶段发生改变(内存重排序 reordering)</li>
<li>运行阶段因 CPU 的缓存机制导致顺序被打乱</li>
</ul>
<h3 id="编译器优化导致内存顺序的改变"><a href="#编译器优化导致内存顺序的改变" class="headerlink" title="编译器优化导致内存顺序的改变"></a>编译器优化导致内存顺序的改变</h3><p>对于第二点，举个例子：</p>
<pre><code class="rust">static mut X: u64 = 0;
static mut Y: u64 = 1;

fn main() &#123;
    ...     // A

    unsafe &#123;
        ... // B
        X = 1;
        ... // C
        Y = 3;
        ... // D
        X = 2;
        ... // E
    &#125;
&#125;
</code></pre>
<p>假如在C和D代码片段中，根本没有用到X &#x3D; 1，那么编译器很可能会将X &#x3D; 1和X &#x3D; 2进行合并:</p>
<pre><code class="rust"> ...     // A

unsafe &#123;
    ... // B
    X = 2;
    ... // C
    Y = 3;
    ... // D
    ... // E
&#125;
</code></pre>
<p>若代码 A 中创建了一个新的线程用于读取全局静态变量 X，则该线程将无法读取到 X &#x3D; 1 的结果，因为在编译阶段就已经被优化掉。</p>
<h3 id="CPU-缓存导致的内存顺序的改变"><a href="#CPU-缓存导致的内存顺序的改变" class="headerlink" title="CPU 缓存导致的内存顺序的改变"></a>CPU 缓存导致的内存顺序的改变</h3><p>假设之前的 X &#x3D; 1 没有被优化掉，并且在代码片段A中有一个新的线程:</p>
<pre><code class="log">initial state: X = 0, Y = 1

THREAD Main     THREAD A
X = 1;          if X == 1 &#123;
Y = 3;              Y *= 2;
X = 2;          &#125;
</code></pre>
<p>由于存在 CPU 缓存，可能导致在主线程中虽然已经将 <code>X</code> 修改为2，但是在线程 A 中由于 CPU 缓存的原因，获取到的 <code>X</code> 仍然为 1.</p>
<h3 id="限定内存顺序的-5-个规则"><a href="#限定内存顺序的-5-个规则" class="headerlink" title="限定内存顺序的 5 个规则"></a>限定内存顺序的 5 个规则</h3><p>在使用 <code>Atomic</code> 操作时，可以通过 <code>Ordering</code> 传递顺序规则，有下面几种规则：</p>
<ul>
<li><strong>Relaxed</strong>: 这是最宽松的规则，它对编译器和 CPU 不做任何限制，可以乱序</li>
<li><strong>Release 释放</strong>: 设定内存屏障(Memory barrier)，保证它之前的操作永远在它之前，但是它后面的操作可能被重排到它前面</li>
<li><strong>Acquire 获取</strong>: 设定内存屏障，保证在它之后的访问永远在它之后，但是它之前的操作却有可能被重排到它后面，往往和 <code>Release</code> 在不同线程中联合使用</li>
<li><strong>AcqRel</strong>: 是 Acquire 和 Release 的结合，同时拥有它们俩提供的保证。比如你要对一个 atomic 自增 1，同时希望该操作之前和之后的读取或写入操作不会被重新排序</li>
<li><strong>SeqCst 顺序一致性</strong>: SeqCst就像是AcqRel的加强版，它不管原子操作是属于读取还是写入的操作，只要某个线程有用到SeqCst的原子操作，线程中该SeqCst操作前的数据操作绝对不会被重新排在该SeqCst操作之后，且该SeqCst操作后的数据操作也绝对不会被重新排在SeqCst操作前。</li>
</ul>
<p>原则上，<code>Acquire</code> 用于读取，而 <code>Release</code> 用于写入。但是由于有些原子操作同时拥有读取和写入的功能，此时就需要使用 <code>AcqRel</code> 来设置内存顺序了。在内存屏障中被写入的数据，都可以被其它线程读取到，不会有 CPU 缓存的问题。</p>
<h3 id="为什么写要用-Release"><a href="#为什么写要用-Release" class="headerlink" title="为什么写要用 Release"></a>为什么写要用 Release</h3><p>写屏障(<code>Ordering::Release</code>)，可以保证所有在屏障之前对<strong>共享内存的操作</strong>不会被重排到屏障之后。</p>
<pre><code class="rust">use std::sync::atomic::&#123;AtomicBool, Ordering&#125;;
use std::thread;

static mut DATA: u64 = 0;
static READY: AtomicBool = AtomicBool::new(false);

fn main() &#123;
    thread::spawn(move || &#123;
        let value = 123;
        unsafe &#123;
            DATA = 100;  // 修改共享数据
        &#125;
        READY.store(true, Ordering::Release);  // 发布操作

        println!(&quot;&#123;value&#125;&quot;);
    &#125;);

    // 假设这里有另一个线程在等待 READY 为 true
    thread::spawn(move || &#123;
        while !READY.load(Ordering::Acquire) &#123;
            // 等待 READY 变为 true
        &#125;

        // READY 为 true 后，确保看到 DATA 的修改
        unsafe &#123;
            println!(&quot;DATA: &#123;&#125;&quot;, DATA);
        &#125;
    &#125;).join().unwrap();
&#125;
</code></pre>
<p>在这个代码中，有两个线程：</p>
<ul>
<li>第一个线程在修改 <code>DATA</code> 之后，使用 <code>READY.store(true, Ordering::Release)</code> 将 <code>READY</code> 设置为 <code>true</code>，这意味着对 <code>DATA</code> 的写操作在内存中被发布（或提交）。</li>
<li>第二个线程不断检查 <code>READY</code>，直到它变为 <code>true</code>，通过 <code>READY.load(Ordering::Acquire)</code> 来同步这个操作。一旦 <code>READY</code> 为 <code>true</code>，它确保在 <code>READY.store(true, Ordering::Release)</code> 之前的所有写操作（包括 <code>DATA = 100</code>）都对该线程可见。</li>
</ul>
<blockquote>
<p>内存同步原语（如 Ordering::Release 和 Ordering::Acquire）只影响共享内存，而不影响线程私有的堆栈空间。</p>
</blockquote>
<h1 id="基于-Send-和-Sync-的线程安全"><a href="#基于-Send-和-Sync-的线程安全" class="headerlink" title="基于 Send 和 Sync 的线程安全"></a>基于 Send 和 Sync 的线程安全</h1><h2 id="Send-和-Sync"><a href="#Send-和-Sync" class="headerlink" title="Send 和 Sync"></a>Send 和 Sync</h2><p><code>Send</code> 和 <code>Sync</code> 是 Rust 安全并发的重中之重，但是实际上它们只是标记特征(marker trait，该特征未定义任何行为), 作用如下：</p>
<ul>
<li>实现 <code>Send</code> 的类型可以在线程间安全的传递其所有权</li>
<li>实现 <code>Sync</code> 的类型可以在线程间安全的共享(通过引用)</li>
</ul>
<p>这里还有一个潜在的依赖：一个类型要在线程间安全的共享的前提是，指向它的引用必须能在线程间传递。因为如果引用都不能被传递，就无法在多个线程间使用引用去访问同一个数据了。</p>
<p>若类型 <code>T</code> 是 <code>Sync</code>，则 <code>T</code> 的引用 <code>&amp;T</code> 是 <code>Send</code>；反之不一定。</p>
<p>例如 <code>RwLock</code> 的实现：</p>
<pre><code class="rust">unsafe impl&lt;T: ?Sized + Send + Sync&gt; Sync for RwLock&lt;T&gt; &#123;&#125;
</code></pre>
<p><code>RwLock</code> 可以在线程间安全的共享，那它肯定是实现了 <code>Sync</code>，而且 <code>RwLock</code> 可以并发的读，说明其中的值 <code>T</code> 必定也可以在线程间共享，那T必定要实现 <code>Sync</code>。</p>
<p>再例如在 <code>Mutex</code> 中:</p>
<pre><code class="rust">unsafe impl&lt;T: ?Sized + Send&gt; Sync for Mutex&lt;T&gt; &#123;&#125;
</code></pre>
<p>不出所料，<code>Mutex&lt;T&gt;</code> 中的T并没有 <code>Sync</code> 特征约束。</p>
<hr>
<p>再比如说 <code>Rc&lt;T&gt;</code>，它没有实现 <code>Send</code> 特征，因为的运用场景中可能导致并发问题：</p>
<pre><code class="rust">use std::rc::Rc;
use std::thread;

fn main() &#123;
    let rc = Rc::new(5);

    let rc_clone = rc.clone();
    thread::spawn(move || &#123;
        println!(&quot;&#123;&#125;&quot;, rc_clone);
    &#125;);

    // 主线程仍然持有 rc 的引用
    println!(&quot;&#123;&#125;&quot;, rc);
&#125;
</code></pre>
<p>在这里，虽然 <code>Rc&lt;T&gt;</code> 的所有权仅能被一个线程持有，但是它的引用就不一定了，上面的代码中，主线程和子线程都拥有了 <code>Rc&lt;T&gt;</code> 的所有权，可能会导致潜在的并发问题。因此 <code>Rc&lt;T&gt;</code> 并没有被<strong>标记</strong>为 <code>Send</code>.</p>
<h2 id="实现-Send-和-Sync-的类型"><a href="#实现-Send-和-Sync-的类型" class="headerlink" title="实现 Send 和 Sync 的类型"></a>实现 Send 和 Sync 的类型</h2><p>在 Rust 中，几乎所有类型都默认实现了 <code>Send</code> 和 <code>Sync</code>，而且由于这两个特征都是可自动派生的特征(通过<code>derive</code>派生)，意味着一个复合类型(例如结构体), 只要它内部的所有成员都实现了 <code>Send</code> 或者 <code>Sync</code>，那么它就自动实现了 <code>Send</code> 或 <code>Sync</code>。</p>
<p>但是有如下几个常见的特例：</p>
<ul>
<li>裸指针两者都没实现，因为它本身就没有任何安全保证</li>
<li>UnsafeCell不是Sync，因此Cell和RefCell也不是</li>
<li>Rc两者都没实现(因为内部的引用计数器不是线程安全的)</li>
</ul>
<p>手动实现 <code>Send</code> 和 <code>Sync</code> 是不安全的，通常并不需要手动实现 <code>Send</code> 和 <code>Sync</code> trait，实现者需要使用 unsafe 小心维护并发安全保证。</p>
<h3 id="为裸指针实现Send"><a href="#为裸指针实现Send" class="headerlink" title="为裸指针实现Send"></a>为裸指针实现Send</h3><p>使用 <code>newtype</code> 类型为 u8 裸指针实现 <code>Send</code>:</p>
<pre><code class="rust">use std::thread;

#[derive(Debug)]
struct MyBox(*mut u8);
unsafe impl Send for MyBox &#123;&#125;
fn main() &#123;
    let p = MyBox(5 as *mut u8);
    let t = thread::spawn(move || &#123;
        println!(&quot;&#123;:?&#125;&quot;,p);
    &#125;);

    t.join().unwrap();
&#125;
</code></pre>
<p>实现 <code>Send</code> 特征并不需要编写额外代码，<strong>仅仅是告诉编译器，这个结构体可以被安全的发送，即便它实际上并不能被安全发送</strong>，也就意味着开发者需要自己保证这个操作是安全的。</p>
<h3 id="为裸指针实现Sync"><a href="#为裸指针实现Sync" class="headerlink" title="为裸指针实现Sync"></a>为裸指针实现Sync</h3><p><code>Sync</code> 是多线程间共享一个值，但是实际上并不能直接共享一个引用：</p>
<pre><code class="rust">use std::thread;
fn main() &#123;
    let v = 5;
    let t = thread::spawn(|| &#123;
        println!(&quot;&#123;:?&#125;&quot;,&amp;v);
    &#125;);

    t.join().unwrap();
&#125;
</code></pre>
<p>上面的代码会报错，原因是编译器无法确定主线程和线程 <code>t</code> 谁的生命周期更长。</p>
<p>因此得配合 <code>Arc</code> 去使用:</p>
<pre><code class="rust">use std::thread;
use std::sync::Arc;
use std::sync::Mutex;

#[derive(Debug)]
struct MyBox(*const u8);
unsafe impl Send for MyBox &#123;&#125;

fn main() &#123;
    let b = &amp;MyBox(5 as *const u8);
    let v = Arc::new(Mutex::new(b));
    let t = thread::spawn(move || &#123;
        let _v1 =  v.lock().unwrap();
    &#125;);

    t.join().unwrap();
&#125;
</code></pre>
<p>上面代码将智能指针 <code>v</code> 的所有权转移给新线程，同时 <code>v</code> 包含了一个引用类型 <code>b</code>，当在新的线程中试图获取内部的引用时，会报错：</p>
<pre><code class="log">error[E0277]: `*const u8` cannot be shared between threads safely
--&gt; src/main.rs:25:13
|
25  |     let t = thread::spawn(move || &#123;
|             ^^^^^^^^^^^^^ `*const u8` cannot be shared between threads safely
|
= help: within `MyBox`, the trait `Sync` is not implemented for `*const u8`
</code></pre>
<p>只需要为 <code>MyBox</code> 实现 <code>Sync</code> 特征就可以了：</p>
<pre><code class="rust">unsafe impl Sync for MyBox &#123;&#125;
</code></pre>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 IceOfSummerの博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;<a target="_blank" rel="noopener" href="https://github.com/IceOfSummer">IceOfSummer</a>
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/IceOfSummer/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        
<script
    src="https://giscus.app/client.js"
    data-repo="IceOfSummer/iceofsummer.github.io"
    data-repo-id="R_kgDOJFU7OQ"
    data-category="Announcements"
    data-category-id="DIC_kwDOJFU7Oc4CUyC7"
    data-mapping="title"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin
    async
></script>





        
    </body>
</html>
