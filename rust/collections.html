
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>集合 | IceOfSummerの博客</title>
        <meta name="author" content="IceOfSummer" />
        <meta name="description" content="后面一辈子的博客都在这了！" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="https://selfb.asia/static/particlex/static/fonts.min.css" />
<script>
  const mixins = {};
  const h = (arg1, arg2, arg3) => {
    if (arg2.attrs) {
      Object.assign(arg2, arg2.attrs)
      Reflect.deleteProperty(arg2, 'attrs')
    }
    if (arg2.on) {
      Object.keys(arg2.on).forEach(key => {
        const head = key.charAt(0).toUpperCase()
        arg2['on' + head  + key.substring(1)] = arg2.on[key]
      })
      Reflect.deleteProperty(arg2, 'on')
    }
    return Vue.h(arg1, arg2, arg3)
  }
</script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

  <script src="/js/lib/toc.js"></script>



  <script src="/js/lib/lazy-load-support.js"></script>


    <meta name="generator" content="Hexo 7.1.1"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存&ensp;浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            </transition>
            <transition name="into">
            <div id="main" v-show="!loading">
                <nav id="menu" ref="menu">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>ICEOFSUMMERの博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" v-show="showMenu" @click="showMenu = !showMenu"></div>
        <div class="title" @click="showMenu = !showMenu">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ICEOFSUMMERの博客</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenu">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

                <div class="article">
    <div>
        <h1>集合</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/1/21
        </span>
        
        <span class="category">
            <a href="/2023/12/04/rust/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Rust
            </a>
        </span>
        
        
    </div>
    
    <toc-component></toc-component>
    <div class="content" v-pre id="main-content">
        <h1 id="1-动态数组-Vector"><a href="#1-动态数组-Vector" class="headerlink" title="1. 动态数组 Vector"></a>1. 动态数组 Vector</h1><h2 id="创建动态数组"><a href="#创建动态数组" class="headerlink" title="创建动态数组"></a>创建动态数组</h2><p>在 Rust 中，有多种方式可以创建动态数组。</p>
<h3 id="Vec-new"><a href="#Vec-new" class="headerlink" title="Vec::new"></a>Vec::new</h3><p>使用 Vec::new 创建动态数组是最 rusty 的方式，它调用了 Vec 中的 new 关联函数：</p>
<pre><code class="rust">let v: Vec&lt;i32&gt; = Vec::new();
</code></pre>
<p>通过<code>Vec::new()</code>时无法传递泛型，因此只能靠类型声明来指定泛型的类型。</p>
<p>或者在操作时，编译器会自动推断：</p>
<pre><code class="rust">let mut v = Vec::new();
v.push(1);
</code></pre>
<p>此时，v 就无需手动声明类型，因为编译器通过 v.push(1)，推测出 v 中的元素类型是 i32，因此推导出 v 的类型是 Vec<i32>。</p>
<blockquote>
<p>如果预先知道要存储的元素个数，可以使用 Vec::with_capacity(capacity) 创建动态数组</p>
</blockquote>
<h3 id="vec"><a href="#vec" class="headerlink" title="vec![]"></a>vec![]</h3><p>还可以使用宏 vec! 来创建数组，与 Vec::new 有所不同，<code>vec![]</code>能在创建的同时给予初始化值：</p>
<pre><code class="rust">let v = vec![1, 2, 3];
let v = vec![0; 3];
</code></pre>
<p>此处 Vec 的类型可直接由编译器推断。</p>
<h3 id="Vec-from"><a href="#Vec-from" class="headerlink" title="Vec::from"></a>Vec::from</h3><p>从已有数组创建：</p>
<pre><code class="rust">let v_from = Vec::from([0, 0, 0]);
</code></pre>
<h2 id="从Vector读取元素"><a href="#从Vector读取元素" class="headerlink" title="从Vector读取元素"></a>从Vector读取元素</h2><p>可以通过下面的方式读取元素：</p>
<ul>
<li>通过下标索引访问</li>
<li>使用<code>get</code>方法</li>
</ul>
<pre><code class="rust">let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
println!(&quot;第三个元素是 &#123;&#125;&quot;, third);

match v.get(2) &#123;
    Some(third) =&gt; println!(&quot;第三个元素是 &#123;third&#125;&quot;),
    None =&gt; println!(&quot;去你的第三个元素，根本没有！&quot;),
&#125;
</code></pre>
<p>使用下标索引时，可以直接拿到对应的值，而不需要进行额外的判断。使用<code>get</code>时，返回的是一个<code>Option</code>的值，需要添加额外的判断。</p>
<p>但是在使用下标索引时，如果索引越界，程序会直接报错退出。</p>
<h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><p>数组元素被引用时，无法进行其它涉及所有权的操作：</p>
<pre><code class="rust">let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);

println!(&quot;The first element is: &#123;first&#125;&quot;);
</code></pre>
<p>其中 <code>first = &amp;v[0]</code> 进行了不可变借用，<code>v.push</code> 进行了可变借用，如果 <code>first</code> 在 <code>v.push</code> 之后不再使用，那么该段代码可以成功编译。</p>
<p>但在最后，<code>first</code>还是被使用了，因此编译器会报错。</p>
<h2 id="遍历集合元素"><a href="#遍历集合元素" class="headerlink" title="遍历集合元素"></a>遍历集合元素</h2><p>如果想要依次访问数组中的元素，可以使用迭代的方式去遍历数组，这种方式比用下标的方式去遍历数组更安全也更高效（每次下标访问都会触发数组边界检查）：</p>
<pre><code class="rust">let v = vec![1, 2, 3];
for i in &amp;v &#123;
    println!(&quot;&#123;i&#125;&quot;);
&#125;
</code></pre>
<p>也可以在迭代过程中，修改 Vector 中的元素:</p>
<pre><code class="rust">let mut v = vec![1, 2, 3];
for i in &amp;mut v &#123;
    *i += 10
&#125;
</code></pre>
<h2 id="Vector-的排序"><a href="#Vector-的排序" class="headerlink" title="Vector 的排序"></a>Vector 的排序</h2><p>在 rust 里，实现了两种排序算法，分别为稳定的排序 sort 和 sort_by，以及非稳定排序 sort_unstable 和 sort_unstable_by。</p>
<p>当然，这个所谓的 非稳定 并不是指排序算法本身不稳定，而是指在排序过程中对相等元素的处理方式。在 稳定 排序算法里，对相等的元素，不会对其进行重新排序。而在 不稳定 的算法里则不保证这点。</p>
<p>总体而言，非稳定 排序的算法的速度会优于 稳定 排序算法，同时，稳定 排序还会额外分配原数组一半的空间。</p>
<pre><code class="rust">fn main() &#123;
    let mut vec = vec![1, 5, 10, 2, 15];    
    vec.sort_unstable();    
    assert_eq!(vec, vec![1, 2, 5, 10, 15]);
&#125;
</code></pre>
<h3 id="对结构体进行排序"><a href="#对结构体进行排序" class="headerlink" title="对结构体进行排序"></a>对结构体进行排序</h3><pre><code class="rust">#[derive(Debug)]
struct Person &#123;
    name: String,
    age: u32,
&#125;

impl Person &#123;
    fn new(name: String, age: u32) -&gt; Person &#123;
        Person &#123; name, age &#125;
    &#125;
&#125;

fn main() &#123;
    let mut people = vec![
        Person::new(&quot;Zoe&quot;.to_string(), 25),
        Person::new(&quot;Al&quot;.to_string(), 60),
        Person::new(&quot;John&quot;.to_string(), 1),
    ];
    // 定义一个按照年龄倒序排序的对比函数
    people.sort_unstable_by(|a, b| b.age.cmp(&amp;a.age));

    println!(&quot;&#123;:?&#125;&quot;, people);
&#125;
</code></pre>
<p>如果结构体实现了 <code>Ord</code> 特性，那么可以直接进行排序，但是实现 <code>Ord</code> 需要我们实现 <code>Ord</code>、<code>Eq</code>、<code>PartialEq</code>、<code>PartialOrd</code> 这些属性。</p>
<p>好在可以直接<code>derive</code>这些属性：</p>
<pre><code class="rust">#[derive(Debug, Ord, Eq, PartialEq, PartialOrd)]
struct Person &#123;
    name: String,
    age: u32,
&#125;

impl Person &#123;
    fn new(name: String, age: u32) -&gt; Person &#123;
        Person &#123; name, age &#125;
    &#125;
&#125;

fn main() &#123;
    let mut people = vec![
        Person::new(&quot;Zoe&quot;.to_string(), 25),
        Person::new(&quot;Al&quot;.to_string(), 60),
        Person::new(&quot;Al&quot;.to_string(), 30),
        Person::new(&quot;John&quot;.to_string(), 1),
        Person::new(&quot;John&quot;.to_string(), 25),
    ];

    people.sort_unstable();

    println!(&quot;&#123;:?&#125;&quot;, people);
&#125;
</code></pre>
<p>需要 <code>derive</code> <code>Ord</code> 相关特性，需要确保你的结构体中所有的属性均实现了 <code>Ord</code> 相关特性，否则会发生编译错误。<code>derive</code> 的默认实现会依据属性的顺序依次进行比较，如上述例子中，当 <code>Person</code> 的 <code>name</code> 值相同，则会使用 <code>age</code> 进行比较。</p>
<h3 id="将类型转换成-Vec"><a href="#将类型转换成-Vec" class="headerlink" title="将类型转换成 Vec"></a>将类型转换成 Vec</h3><p>只要为 Vec 实现了 From<T> 特征，那么 T 就可以被转换成 Vec。</p>
<pre><code class="rust">struct Test &#123;
    value: i32
&#125;

impl From&lt;i32&gt; for Test &#123;

    fn from(value: i32) -&gt; Self &#123;
        Test &#123; value &#125;
    &#125;
&#125;

impl Into&lt;i32&gt; for Test &#123;
    fn into(self) -&gt; i32 &#123;
        self.value
    &#125;
&#125;

impl From&lt;Test&gt; for Vec&lt;Test&gt; &#123;
    fn from(value: Test) -&gt; Self &#123;
        vec![value]
    &#125;
&#125;

// 填空
fn main() &#123;
    let v = Test::from(1);
    // ok
    let val: Vec&lt;Test&gt; = v.into();

    let v2 = Test::from(1);
    // ok
    let val2: i32 = v2.into();
&#125;
</code></pre>
<p>必须要加上类型声明，编译器不会为我们主动推断。</p>
<h1 id="2-KV-存储-HashMap"><a href="#2-KV-存储-HashMap" class="headerlink" title="2. KV 存储 HashMap"></a>2. KV 存储 HashMap</h1><h2 id="创建HashMap"><a href="#创建HashMap" class="headerlink" title="创建HashMap"></a>创建HashMap</h2><p>跟创建动态数组 Vec 的方法类似，可以使用 new 方法来创建 HashMap，然后通过 insert 方法插入键值对。</p>
<pre><code class="rust">use std::collections::HashMap;

// 创建一个HashMap，用于存储宝石种类和对应的数量
let mut my_gems = HashMap::new();

// 将宝石类型和对应的数量写入表中
my_gems.insert(&quot;红宝石&quot;, 1);
my_gems.insert(&quot;蓝宝石&quot;, 2);
my_gems.insert(&quot;河边捡的误以为是宝石的破石头&quot;, 18);
</code></pre>
<p>任何实现了 <code>Eq</code> 和 <code>Hash</code> 特征的类型都可以用于 HashMap 的 key。</p>
<h2 id="所有权转移"><a href="#所有权转移" class="headerlink" title="所有权转移"></a>所有权转移</h2><p>HashMap 的所有权规则与其它 Rust 类型没有区别：</p>
<ul>
<li>若类型实现 Copy 特征，该类型会被复制进 HashMap，因此无所谓所有权</li>
<li>若没实现 Copy 特征，所有权将被转移给 HashMap 中</li>
</ul>
<pre><code class="rust">fn main() &#123;
    use std::collections::HashMap;

    let name = String::from(&quot;Sunface&quot;);
    let age = 18;

    let mut handsome_boys = HashMap::new();
    handsome_boys.insert(name, age);

    // 错误，所有权已经被转移走了
    println!(&quot;&#123;&#125;&quot;, name);
    // 正确，age被复制了
    println!(&quot;还有，他的真实年龄远远不止&#123;&#125;岁&quot;, age);
&#125;
</code></pre>
<h2 id="查询HashMap"><a href="#查询HashMap" class="headerlink" title="查询HashMap"></a>查询HashMap</h2><p>通过<code>get</code>方法可以获取元素：</p>
<pre><code class="rust">use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
let score: Option&lt;&amp;i32&gt; = scores.get(&amp;team_name);
</code></pre>
<p><code>get</code> 方法返回一个 <code>Option&lt;&amp;i32&gt;</code> 类型：当查询不到时，会返回一个 <code>None</code>，查询到时返回 <code>Some(&amp;i32)</code></p>
<p>并且返回的是一个借用的值，而不是直接带着所有权返回原始的值。</p>
<p>如果需要获取不带引用的值，可以尝试使用<code>Optional</code>的<code>copied</code>方法：</p>
<pre><code class="rust">let score: i32 = scores.get(&amp;team_name).copied().unwrap_or(0);
</code></pre>
<p>如果需要调用<code>copied</code>，则必须保证实现了<code>Copy</code>方法，否则会报错。</p>
<h3 id="遍历-HashMap"><a href="#遍历-HashMap" class="headerlink" title="遍历 HashMap"></a>遍历 HashMap</h3><pre><code class="rust">use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

for (key, value) in &amp;scores &#123;
    println!(&quot;&#123;&#125;: &#123;&#125;&quot;, key, value);
&#125;
</code></pre>
<h2 id="更新-HashMap-中的值"><a href="#更新-HashMap-中的值" class="headerlink" title="更新 HashMap 中的值"></a>更新 HashMap 中的值</h2><pre><code class="rust">fn main() &#123;
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(&quot;Blue&quot;, 10);

    // 覆盖已有的值
    let old = scores.insert(&quot;Blue&quot;, 20);
    assert_eq!(old, Some(10));

    // 查询新插入的值
    let new = scores.get(&quot;Blue&quot;);
    assert_eq!(new, Some(&amp;20));

    // 查询Yellow对应的值，若不存在则插入新值
    let v = scores.entry(&quot;Yellow&quot;).or_insert(5);
    assert_eq!(*v, 5); // 不存在，插入5

    // 查询Yellow对应的值，若不存在则插入新值
    let v = scores.entry(&quot;Yellow&quot;).or_insert(50);
    assert_eq!(*v, 5); // 已经存在，因此50没有插入
&#125;
</code></pre>
<h3 id="在已有值的基础上更新"><a href="#在已有值的基础上更新" class="headerlink" title="在已有值的基础上更新"></a>在已有值的基础上更新</h3><p>另一个常用场景如下：查询某个 key 对应的值，若不存在则插入新值，若存在则对已有的值进行更新，例如在文本中统计词语出现的次数：</p>
<pre><code class="rust">let v = scores.entry(&quot;Yellow&quot;).or_insert(50);
*v += 1;
</code></pre>
<p>也可以通过调用函数获取默认值：</p>
<pre><code class="rust">let v = scores.entry(&quot;Yellow&quot;).or_insert_with(50);

fn random_stat_buff() -&gt; u8 &#123;
    // 为了简单，我们没有使用随机，而是返回一个固定的值
    42
&#125;
</code></pre>
<h3 id="为结构体实现-Hash-特征"><a href="#为结构体实现-Hash-特征" class="headerlink" title="为结构体实现 Hash 特征"></a>为结构体实现 Hash 特征</h3><p>使用<code>#[derive(Hash)]</code>可以将所有属性作为 Hash 结果的一部分计算。</p>
<p>也可以控制使用哪些字段进行计算：</p>
<pre><code class="rust">use std::hash::&#123;Hash, Hasher&#125;;

struct Person &#123;
    id: u32,
    name: String,
    phone: u64,
&#125;

impl Hash for Person &#123;
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) &#123;
        self.id.hash(state);
        self.phone.hash(state);
    &#125;
&#125;
</code></pre>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 IceOfSummerの博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;<a target="_blank" rel="noopener" href="https://github.com/IceOfSummer">IceOfSummer</a>
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/IceOfSummer/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        
<script
    src="https://giscus.app/client.js"
    data-repo="IceOfSummer/iceofsummer.github.io"
    data-repo-id="R_kgDOJFU7OQ"
    data-category="Announcements"
    data-category-id="DIC_kwDOJFU7Oc4CUyC7"
    data-mapping="title"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin
    async
></script>





        
    </body>
</html>
