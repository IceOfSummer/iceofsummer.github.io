
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>流程控制 | IceOfSummerの博客</title>
        <meta name="author" content="IceOfSummer" />
        <meta name="description" content="后面一辈子的博客都在这了！" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="https://selfb.asia/static/particlex/static/fonts.min.css" />
<script>
  const mixins = {};
  const h = (arg1, arg2, arg3) => {
    if (arg2.attrs) {
      Object.assign(arg2, arg2.attrs)
      Reflect.deleteProperty(arg2, 'attrs')
    }
    if (arg2.on) {
      Object.keys(arg2.on).forEach(key => {
        const head = key.charAt(0).toUpperCase()
        arg2['on' + head  + key.substring(1)] = arg2.on[key]
      })
      Reflect.deleteProperty(arg2, 'on')
    }
    return Vue.h(arg1, arg2, arg3)
  }
</script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

  <script src="/js/lib/toc.js"></script>



  <script src="/js/lib/lazy-load-support.js"></script>


    <meta name="generator" content="Hexo 7.1.1"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存&ensp;浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            </transition>
            <transition name="into">
            <div id="main" v-show="!loading">
                <nav id="menu" ref="menu">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>ICEOFSUMMERの博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" v-show="showMenu" @click="showMenu = !showMenu"></div>
        <div class="title" @click="showMenu = !showMenu">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ICEOFSUMMERの博客</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenu">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

                <div class="article">
    <div>
        <h1>流程控制</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/12/26
        </span>
        
        <span class="category">
            <a href="/2023/12/04/rust/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Rust
            </a>
        </span>
        
        
    </div>
    
    <toc-component></toc-component>
    <div class="content" v-pre id="main-content">
        <h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><h2 id="1-1-if判断"><a href="#1-1-if判断" class="headerlink" title="1.1 if判断"></a>1.1 if判断</h2><p>rust的if表达式如下：</p>
<pre><code class="rust">if condition == true &#123;
    // A...
&#125; else &#123;
    // B...
&#125;
</code></pre>
<p>在rust中的三目运算符也需要if来完成：</p>
<pre><code class="rust">fn main() &#123;
    let condition = true;
    let number = if condition &#123;
        5
    &#125; else &#123;
        6
    &#125;;

    println!(&quot;The value of number is: &#123;&#125;&quot;, number);
&#125;
</code></pre>
<p>用 if 来赋值时，要保证每个分支返回的类型一样，不然编译会报错。</p>
<h2 id="1-2-for循环"><a href="#1-2-for循环" class="headerlink" title="1.2 for循环"></a>1.2 for循环</h2><p>rust的for循环和寻常的语言不一样，例如从1到5是这样写的：</p>
<pre><code class="rust">fn main() &#123;
    for i in 1..=5 &#123;
        println!(&quot;&#123;&#125;&quot;, i);
    &#125;
&#125;
</code></pre>
<p>加上等号代表范围是[1, 5]，去掉则是[1, 5)。</p>
<p>主要的语义表达式如下：</p>
<pre><code class="rust">for 元素 in 集合 &#123;
  // 使用元素干一些你懂我不懂的事情
&#125;
</code></pre>
<p>如果想在循环中，修改该元素，可以使用 mut 关键字：</p>
<pre><code class="rust">fn main() &#123;
    let mut collection = [1, 2, 3, 4, 5];
    for val in &amp;mut collection &#123;
        *val = 3;
    &#125;

    for val in &amp;collection &#123;
        // output: 3 3 3 3 3 3
        println!(&quot;&#123;&#125;&quot;, val)
    &#125;
&#125;
</code></pre>
<p><strong>在使用时，如果传入的集合不是一个引用，那么对应的所有权将会被转移走</strong>。</p>
<table>
<thead>
<tr>
<th>使用方法</th>
<th>等价使用方式</th>
<th>所有权</th>
</tr>
</thead>
<tbody><tr>
<td><code>for item in collection</code></td>
<td><code>for item in IntoIterator::into_iter(collection)</code></td>
<td>转移所有权</td>
</tr>
<tr>
<td><code>for item in &amp;collection</code></td>
<td><code>for item in collection.iter()</code></td>
<td>不可变借用</td>
</tr>
<tr>
<td><code>for item in &amp;mut collection</code></td>
<td><code>for item in collection.iter_mut()</code></td>
<td>可变借用</td>
</tr>
</tbody></table>
<h2 id="1-3-while循环"><a href="#1-3-while循环" class="headerlink" title="1.3 while循环"></a>1.3 while循环</h2><pre><code class="rust">fn main() &#123;
    let mut n = 0;

    while n &lt;= 5 &#123;
        println!(&quot;&#123;&#125;!&quot;, n);

        n = n + 1;
    &#125;

    println!(&quot;我出来了！&quot;);
&#125;
</code></pre>
<h2 id="1-4-loop循环"><a href="#1-4-loop循环" class="headerlink" title="1.4 loop循环"></a>1.4 loop循环</h2><p>loop循环可以理解为简化版的while true循环，代码块中的代码会一直运行，直到返回或退出。</p>
<pre><code class="rust">fn main() &#123;
    let mut counter = 0;

    let result = loop &#123;
        counter += 1;

        if counter == 10 &#123;
            break counter * 2;
        &#125;
    &#125;;

    println!(&quot;The result is &#123;&#125;&quot;, result);
&#125;
</code></pre>
<p>使用<code>label</code>可以控制<code>continue</code>和<code>break</code>的位置：</p>
<pre><code class="rust">fn main() &#123;
    let mut count = 0;
    &#39;outer: loop &#123;
        &#39;inner1: loop &#123;
            if count &gt;= 20 &#123;
                // 这只会跳出 inner1 循环
                break &#39;inner1; // 这里使用 `break` 也是一样的
            &#125;
            count += 2;
        &#125;
        count += 5;
        &#39;inner2: loop &#123;
            if count &gt;= 30 &#123;
                break &#39;outer;
            &#125;
            continue &#39;outer;
        &#125;
    &#125;
    assert!(count == 30)
&#125;
</code></pre>
<h1 id="2-模式匹配"><a href="#2-模式匹配" class="headerlink" title="2. 模式匹配"></a>2. 模式匹配</h1><h2 id="2-1-match匹配"><a href="#2-1-match匹配" class="headerlink" title="2.1 match匹配"></a>2.1 match匹配</h2><p>在 Rust 中，模式匹配最常用的就是 match 和 if let，下面是match的一个例子：</p>
<pre><code class="rust">enum Direction &#123;
    East,
    West,
    North,
    South,
&#125;

fn main() &#123;
    let dire = Direction::South;
    match dire &#123;
        Direction::East =&gt; println!(&quot;East&quot;),
        Direction::North | Direction::South =&gt; &#123;
            println!(&quot;South or North&quot;);
        &#125;,
        _ =&gt; println!(&quot;West&quot;),
    &#125;;
&#125;
</code></pre>
<p>这里我们想去匹配 dire 对应的枚举类型，因此在 match 中用三个匹配分支来完全覆盖枚举变量 Direction 的所有成员类型，有以下几点值得注意：</p>
<ul>
<li>match 的匹配必须要穷举出所有可能，因此这里用 _ 来代表未列出的所有可能性</li>
<li>match 的每一个分支都必须是一个表达式，且所有分支的表达式最终返回值的类型必须相同</li>
<li>X | Y，类似逻辑运算符 或，代表该分支可以匹配 X 也可以匹配 Y，只要满足一个即可</li>
</ul>
<p>其实 match 跟其他语言中的 switch 非常像，_ 类似于 switch 中的 default，如果没有默认，则match必须要覆盖所有的值，不然会报错。</p>
<p>match匹配的通用形式：</p>
<pre><code class="rust">match target &#123;
    模式1 =&gt; 表达式1,
    模式2 =&gt; &#123;
        语句1;
        语句2;
        表达式2
    &#125;,
    _ =&gt; 表达式3
&#125;
</code></pre>
<p>match可以用于返回值：</p>
<pre><code class="rust">enum Coin &#123;
    Penny,
    Nickel,
    Dime,
    Quarter,
&#125;

fn value_in_cents(coin: Coin) -&gt; u8 &#123;
    match coin &#123;
        Coin::Penny =&gt;  &#123;
            println!(&quot;Lucky penny!&quot;);
            1
        &#125;,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    &#125;
&#125;
</code></pre>
<p>也可以给变量赋值：</p>
<pre><code class="rust">enum IpAddr &#123;
   Ipv4,
   Ipv6
&#125;

fn main() &#123;
    let ip1 = IpAddr::Ipv6;
    let ip_str = match ip1 &#123;
        IpAddr::Ipv4 =&gt; &quot;127.0.0.1&quot;,
        _ =&gt; &quot;::1&quot;,
    &#125;;

    println!(&quot;&#123;&#125;&quot;, ip_str);
&#125;
</code></pre>
<h3 id="2-1-1-模式绑定"><a href="#2-1-1-模式绑定" class="headerlink" title="2.1.1 模式绑定"></a>2.1.1 模式绑定</h3><p>模式匹配的另外一个重要功能是从模式中取出绑定的值，例如：</p>
<pre><code class="rust">#[derive(Debug)]
enum UsState &#123;
    Alabama,
    Alaska,
    // --snip--
&#125;

enum Coin &#123;
    Penny,
    Nickel,
    Dime,
    Quarter(UsState), // 25美分硬币
&#125;
</code></pre>
<p>其中 Coin::Quarter 成员还存放了一个值，可以通过模式绑定取到这个值：</p>
<pre><code class="rust">fn value_in_cents(coin: Coin) -&gt; u8 &#123;
    match coin &#123;
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; &#123;
            println!(&quot;State quarter from &#123;:?&#125;!&quot;, state);
            25
        &#125;,
    &#125;
&#125;
</code></pre>
<h3 id="2-1-2-通配符"><a href="#2-1-2-通配符" class="headerlink" title="2.1.2 _通配符"></a>2.1.2 _通配符</h3><p>通配符提供了一种默认的处理方式：</p>
<pre><code class="rust">let some_u8_value = 0u8;
match some_u8_value &#123;
    1 =&gt; println!(&quot;one&quot;),
    3 =&gt; println!(&quot;three&quot;),
    5 =&gt; println!(&quot;five&quot;),
    7 =&gt; println!(&quot;seven&quot;),
    _ =&gt; (),
&#125;
</code></pre>
<p>如果不使用通配符，则需要覆盖所有情况。</p>
<p>除了使用通配符，用一个变量来承载其它情况也是可以的：</p>
<pre><code class="rust">#[derive(Debug)]
enum Direction &#123;
    East,
    West,
    North,
    South,
&#125;

fn main() &#123;
    let dire = Direction::South;
    match dire &#123;
        Direction::East =&gt; println!(&quot;East&quot;),
        other =&gt; println!(&quot;other direction: &#123;:?&#125;&quot;, other),
    &#125;;
&#125;
</code></pre>
<h2 id="2-2-if-let匹配"><a href="#2-2-if-let匹配" class="headerlink" title="2.2 if let匹配"></a>2.2 if let匹配</h2><p>有时会遇到只有一个模式的值需要被处理，其它值直接忽略的场景，如果用 match 来处理就要写成下面这样：</p>
<pre><code class="rust">let v = Some(3u8);
match v &#123;
    Some(3) =&gt; println!(&quot;three&quot;),
    _ =&gt; (),
&#125;
</code></pre>
<p>为了减少代码量，可以使用<code>if let</code>的方式来替换：</p>
<pre><code class="rust">if let Some(3) = v &#123;
    println!(&quot;three&quot;);
&#125;
</code></pre>
<p>当只要匹配一个条件，且忽略其他条件时就用 <code>if let</code> ，否则都用 <code>match</code>。</p>
<h2 id="2-3-matches-宏"><a href="#2-3-matches-宏" class="headerlink" title="2.3 matches! 宏"></a>2.3 matches! 宏</h2><p><code>matches!</code>宏用于匹配两个变量，返回一个布尔值，它可以用于快速进行匹配：</p>
<pre><code class="rust">let foo = &#39;f&#39;;
assert!(matches!(foo, &#39;A&#39;..=&#39;Z&#39; | &#39;a&#39;..=&#39;z&#39;));

let bar = Some(4);
assert!(matches!(bar, Some(x) if x &gt; 2));
</code></pre>
<h2 id="2-4-while-let-条件循环"><a href="#2-4-while-let-条件循环" class="headerlink" title="2.4 while let 条件循环"></a>2.4 while let 条件循环</h2><p>一个与 if let 类似的结构是 while let 条件循环，它允许只要模式匹配就一直进行 while 循环。下面展示了一个使用 while let 的例子：</p>
<pre><code class="rust">// Vec是动态数组
let mut stack = Vec::new();

// 向数组尾部插入元素
stack.push(1);
stack.push(2);
stack.push(3);

// stack.pop从数组尾部弹出元素
while let Some(top) = stack.pop() &#123;
    println!(&quot;&#123;&#125;&quot;, top);
&#125;
</code></pre>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 IceOfSummerの博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;<a target="_blank" rel="noopener" href="https://github.com/IceOfSummer">IceOfSummer</a>
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/IceOfSummer/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        
<script
    src="https://giscus.app/client.js"
    data-repo="IceOfSummer/iceofsummer.github.io"
    data-repo-id="R_kgDOJFU7OQ"
    data-category="Announcements"
    data-category-id="DIC_kwDOJFU7Oc4CUyC7"
    data-mapping="title"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin
    async
></script>





        
    </body>
</html>
