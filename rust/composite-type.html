
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>复合类型 | IceOfSummerの博客</title>
        <meta name="author" content="IceOfSummer" />
        <meta name="description" content="用来用去还是自己搭的博客靠谱" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="https://selfb.asia/static/particlex/static/fonts.min.css" />
<script>
  const mixins = {};
  const h = (arg1, arg2, arg3) => {
    if (arg2.attrs) {
      Object.assign(arg2, arg2.attrs)
      Reflect.deleteProperty(arg2, 'attrs')
    }
    if (arg2.on) {
      Object.keys(arg2.on).forEach(key => {
        const head = key.charAt(0).toUpperCase()
        arg2['on' + head  + key.substring(1)] = arg2.on[key]
      })
      Reflect.deleteProperty(arg2, 'on')
    }
    return Vue.h(arg1, arg2, arg3)
  }
</script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

  <script src="/js/lib/toc.js"></script>



  <script src="/js/lib/lazy-load-support.js"></script>


    <meta name="generator" content="Hexo 7.1.1"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存&ensp;浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            </transition>
            <transition name="into">
            <div id="main" v-show="!loading">
                <nav id="menu" ref="menu">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>ICEOFSUMMERの博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" v-show="showMenu" @click="showMenu = !showMenu"></div>
        <div class="title" @click="showMenu = !showMenu">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ICEOFSUMMERの博客</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenu">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

                <div class="article">
    <div>
        <h1>复合类型</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/12/19
        </span>
        
        <span class="category">
            <a href="/2023/12/04/Rust/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Rust
            </a>
        </span>
        
        
    </div>
    
    <toc-component></toc-component>
    <div class="content" v-pre id="main-content">
        <h1 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1. 字符串"></a>1. 字符串</h1><h2 id="1-1-切片"><a href="#1-1-切片" class="headerlink" title="1.1 切片"></a>1.1 切片</h2><p>切片可以让我们引用集合中部分连续的元素序列，而不是引用整个集合。</p>
<p>对于字符串而言，切片就是对<code>String</code>类型中某一部分的引用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br></pre></td></tr></table></figure>

<p>对于一个切片，它并没有实际地去拷贝集合中的东西：</p>
<p><img lazy="https://selfb.asia/blog/v2-69da917741b2c610732d8526a9cc86f5_1440w.jpg" alt="slice"></p>
<p>如果想从某个位置到结尾或者开头，可以这样写：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开头到索引为2的位置</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引为4到结尾</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">4</span>..];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 甚至全部切片。。</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..];</span><br></pre></td></tr></table></figure>

<p>对字符串使用切片时，如果索引没有落到边界位置，代码则会导致崩溃。</p>
<p>例如汉字在UTF-8中占三个字节，下面的代码会导致崩溃:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;中国人&quot;</span>;</span><br><span class="line"><span class="comment">// 在这里就报错了，并没有走到后面的打印语句</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = &amp;s[<span class="number">0</span>..<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,a);</span><br></pre></td></tr></table></figure>

<p>报错信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte index 2 is not a char boundary; it is inside &#x27;中&#x27; (bytes 0..3) of `中国人`</span><br><span class="line">stack backtrace:</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="1-2-str和String以及-str"><a href="#1-2-str和String以及-str" class="headerlink" title="1.2 str和String以及&amp;str"></a>1.2 str和String以及&amp;str</h2><p>str只是类型级别的东西，它只能用来在类型级别上发挥作用，它是动态大小类型，因此str占用的大小在编译时无法确定，只能在<br>运行时才能确定，所以无法将其存储在变量中:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = s[..];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = b;</span><br></pre></td></tr></table></figure>
<p>报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  |</span><br><span class="line">6 |     let a = b;</span><br><span class="line">  |         ^ doesn&#x27;t have a size known at compile-time</span><br><span class="line">  |</span><br></pre></td></tr></table></figure>

<p>str代表u8字节的一个数组，而且保证其形成有效的UTF-8，但是不知道其大小，它会被硬编码进可执行文件，也无法被修改。</p>
<p>可以理解为String内容有一个str并且拥有其所有权，而&amp;str只有一个可读引用。</p>
<blockquote>
<p>其实这里我当初也没明白，我都用双引号来给字符串了，而且又是UTF-8，长度怎么就不明白呢？</p>
<p>到后面查了很多资料才明白了，首先是因为<code>str</code>类型的字符串它没有保存长度，而<code>&amp;str</code>保存了长度，具体为什么不保存长度我也不知道，网上也没有搜到相关内容，个人猜测是为了字符串复用？然后我们知道Rust的GC是自动的，变量退出作用域自动被回收，但是回收的前提是你需要知道这个变量在内存的什么位置，以及它的大小，而<code>str</code>类型是没有保存大小的，如果直接放到变量中使用，是无法进行内存回收的，因为不知道其具体大小，例如下面的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test</span>(val: <span class="type">str</span>) &#123;</span><br><span class="line">  <span class="comment">// xxx   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在这里获取了<code>str</code>的所有权，在函数结束时就需要将其回收，而在这里无法确定str的大小，因此无法进行回收。</p>
</blockquote>
<h2 id="1-3-字符串索引"><a href="#1-3-字符串索引" class="headerlink" title="1.3 字符串索引"></a>1.3 字符串索引</h2><p>在rust中，使用索引访问字符串的某个字符会导致报错：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">h</span> = s1[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 |     let h = s1[0];</span><br><span class="line">  |             ^^^^^ `String` cannot be indexed by `&#123;integer&#125;`</span><br><span class="line">  |</span><br><span class="line">  = help: the trait `Index&amp;lt;&#123;integer&#125;&amp;gt;` is not implemented for `String`</span><br></pre></td></tr></table></figure>

<p>在字符串底层的数据存储格式实际上是一个<code>u8</code>数组，而UTF-8中，每种类型的字符所占的字节都不一样，所以无法使用<br>索引来取值。</p>
<h2 id="1-4-字符串操作"><a href="#1-4-字符串操作" class="headerlink" title="1.4 字符串操作"></a>1.4 字符串操作</h2><h3 id="1-4-1-追加"><a href="#1-4-1-追加" class="headerlink" title="1.4.1 追加"></a>1.4.1 追加</h3><ul>
<li><code>push()</code>: 追加字符<code>char</code></li>
<li><code>push_str()</code>：追加字符串字面量</li>
</ul>
<p>追加要求被修改的字符串必须是可变的，所以对应的变量必须被mut修饰：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;rust&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;追加字符串 push_str() -&amp;gt; &#123;&#125;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;追加字符 push() -&amp;gt; &#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-2-插入"><a href="#1-4-2-插入" class="headerlink" title="1.4.2 插入"></a>1.4.2 插入</h3><ul>
<li><code>insert()</code>：插入单个字符<code>char</code></li>
<li><code>insert_str()</code>：插入字符串字面量</li>
</ul>
<p>插入方法同时需要提供插入的索引，并且也需要保证插入位置在字符的边界:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello rust!&quot;</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">insert</span>(<span class="number">5</span>, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;插入字符 insert() -&amp;gt; &#123;&#125;&quot;</span>, s);</span><br><span class="line">    s.<span class="title function_ invoke__">insert_str</span>(<span class="number">6</span>, <span class="string">&quot; I like&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;插入字符串 insert_str() -&amp;gt; &#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-3-替换"><a href="#1-4-3-替换" class="headerlink" title="1.4.3 替换"></a>1.4.3 替换</h3><ul>
<li><code>replace()</code>：可同时用在<code>&amp;str</code>和<code>String</code>类型上，会替换掉所有满足的字符串。</li>
<li><code>replacen()</code>：可同时用在<code>&amp;str</code>和<code>String</code>类型上，接收三个参数，前两个参数与 replace() 方法一样，第三个参数则表示替换的个数。</li>
<li><code>replace_range()</code>：只能在<code>String</code>上使用，表示替换一定范围内的字符串。</li>
</ul>
<p><strong>上面的方法都会返回一个新的字符串，而不是操作原来的字符串。</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">string_replace</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;I like rust. Learning rust is my favorite!&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;I like RUST. Learning RUST is my favorite!&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">new_string_replace</span> = string_replace.<span class="title function_ invoke__">replace</span>(<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;RUST&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">string_replace</span> = <span class="string">&quot;I like rust. Learning rust is my favorite!&quot;</span>;</span><br><span class="line"><span class="comment">// I like RUST. Learning rust is my favorite!</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">new_string_replacen</span> = string_replace.<span class="title function_ invoke__">replacen</span>(<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;RUST&quot;</span>, <span class="number">1</span>);</span><br><span class="line">dbg!(new_string_replacen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">string_replace_range</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;I like rust!&quot;</span>);</span><br><span class="line"><span class="comment">// I like Rust!</span></span><br><span class="line">string_replace_range.<span class="title function_ invoke__">replace_range</span>(<span class="number">7</span>..<span class="number">8</span>, <span class="string">&quot;R&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="1-4-4-删除"><a href="#1-4-4-删除" class="headerlink" title="1.4.4 删除"></a>1.4.4 删除</h3><p>删除相关的方法都只适用于<code>String</code>，并且都会改变原来的字符串。</p>
<ul>
<li><code>pop()</code>：删除并返回字符串的最后一个字符</li>
<li><code>remove()</code>：删除并返回字符串中指定位置的字符，使用时需要保证索引在字符边界的起始位置</li>
<li><code>truncate()</code>：删除字符串中从指定位置开始到结尾的全部字符，需要保证索引在字符的结束位置</li>
<li><code>clear()</code>：清空字符串，类似于<code>truncate(0)</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">string_pop</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;rust pop 中文&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;文&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">p1</span> = string_pop.<span class="title function_ invoke__">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">string_remove</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;测试remove方法&quot;</span>);</span><br><span class="line"> <span class="comment">// 删除第一个汉字</span></span><br><span class="line">string_remove.<span class="title function_ invoke__">remove</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 下面代码会发生错误</span></span><br><span class="line"><span class="comment">// string_remove.remove(1);</span></span><br><span class="line"><span class="comment">// 直接删除第二个汉字</span></span><br><span class="line"><span class="comment">// string_remove.remove(3);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">string_truncate</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;测试truncate&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;测&quot;</span></span><br><span class="line">string_truncate.<span class="title function_ invoke__">truncate</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h3 id="1-4-5-连接"><a href="#1-4-5-连接" class="headerlink" title="1.4.5 连接"></a>1.4.5 连接</h3><h4 id="使用-连接字符串"><a href="#使用-连接字符串" class="headerlink" title="使用+连接字符串"></a>使用<code>+</code>连接字符串</h4><p>可以使用<code>+</code>或者<code>+=</code>连接字符串，要求右边的参数必须为字符串的切片引用类型。<code>+</code>返回的是一个新的字符串，操作时可以不需要<code>mut</code>关键字。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string_append</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string_rust</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;rust&quot;</span>);</span><br><span class="line">    <span class="comment">// &amp;string_rust会自动解引用为&amp;str</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = string_append + &amp;string_rust;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span> = result + <span class="string">&quot;!&quot;</span>; <span class="comment">// `result + &quot;!&quot;` 中的 `result` 是不可变的</span></span><br><span class="line">    result += <span class="string">&quot;!!!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接字符串 + -&amp;gt; hello rust!!!!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;连接字符串 + -&amp;gt; &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于以下代码会导致报错：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello,&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line">    <span class="comment">// 在下句中，s1的所有权被转移走了，因此后面不能再使用s1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s3,<span class="string">&quot;hello,world!&quot;</span>);</span><br><span class="line">    <span class="comment">// 下面的语句如果去掉注释，就会报错</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;&#125;&quot;,s1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来很难理解，其实换一下就知道了，<code>add</code>的类型定义为：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&amp;gt;</span> <span class="type">String</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们换成add来看：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&quot;ss&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = a.<span class="title function_ invoke__">add</span>(<span class="string">&quot;eee&quot;</span>);</span><br><span class="line"><span class="comment">// 报错，a已经转移给b</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br></pre></td></tr></table></figure>

<p>这里我们就可以理解为调用<code>add</code>方法后，变量<code>a</code>返回了它自己。</p>
<h4 id="使用format-连接字符串"><a href="#使用format-连接字符串" class="headerlink" title="使用format!连接字符串"></a>使用<code>format!</code>连接字符串</h4><p>format! 这种方式适用于 String 和 &amp;str 。format! 的用法与 print! 的用法类似，详见<a target="_blank" rel="noopener" href="https://course.rs/basic/formatted-output.html#printprintlnformat">格式化输出</a>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;rust&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;!&quot;</span>, s1, s2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hello rust!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-字符串转义"><a href="#1-5-字符串转义" class="headerlink" title="1.5 字符串转义"></a>1.5 字符串转义</h2><p>可以通过转义(<code>\</code>)的方式输出 ASCII 和 Unicode 字符。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 通过 \ + 字符的十六进制表示，转义输出一个字符</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">byte_escape</span> = <span class="string">&quot;I&#x27;m writing \x52\x75\x73\x74!&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;What are you doing\x3F (\\x3F means ?) &#123;&#125;&quot;</span>, byte_escape);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// \u 可以输出一个 unicode 字符</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">unicode_codepoint</span> = <span class="string">&quot;\u&#123;211D&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">character_name</span> = <span class="string">&quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;Unicode character &#123;&#125; (U+211D) is called &#123;&#125;&quot;</span>,</span><br><span class="line">        unicode_codepoint, character_name</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 换行了也会保持之前的字符串格式</span></span><br><span class="line">    <span class="comment">// 使用\忽略换行符</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">long_string</span> = <span class="string">&quot;String literals</span></span><br><span class="line"><span class="string">                        can span multiple lines.</span></span><br><span class="line"><span class="string">                        The linebreak and indentation here -&amp;gt;\</span></span><br><span class="line"><span class="string">                        &amp;lt;- can be escaped too!&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, long_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特殊的转义符：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;hello \\x52\\x75\\x73\\x74&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">raw_str</span> = <span class="string">r&quot;Escapes don&#x27;t work here: \x3F \u&#123;211D&#125;&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, raw_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果字符串包含双引号，可以在开头和结尾加 #</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">quotes</span> = <span class="string">r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, quotes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还是有歧义，可以继续增加，没有限制</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">longer_delimiter</span> = <span class="string">r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, longer_delimiter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-操作-UTF-8-字符串"><a href="#1-6-操作-UTF-8-字符串" class="headerlink" title="1.6 操作 UTF-8 字符串"></a>1.6 操作 UTF-8 字符串</h2><p>以 Unicode 字符的方式遍历字符串：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="string">&quot;中国人&quot;</span>.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">中</span><br><span class="line">国</span><br><span class="line">人</span><br></pre></td></tr></table></figure>

<p>以字节的方式遍历：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> <span class="string">&quot;中国人&quot;</span>.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">228</span><br><span class="line">184</span><br><span class="line">173</span><br><span class="line">229</span><br><span class="line">155</span><br><span class="line">189</span><br><span class="line">228</span><br><span class="line">186</span><br><span class="line">186</span><br></pre></td></tr></table></figure>

<p>如果需要精准的从UTF-8字符串中获取子串，可能需要借助其它的标准库，例如：<a target="_blank" rel="noopener" href="https://crates.io/crates/utf8_slice">utf8_slice</a></p>
<h1 id="2-元组"><a href="#2-元组" class="headerlink" title="2. 元组"></a>2. 元组</h1><p>元组是由多种类型组合到一起形成的，因此它是复合类型，元组的长度是固定的，元组中元素的顺序也是固定的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取元组的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">five_hundred</span> = x.<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six_point_four</span> = x.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">one</span> = x.<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-结构体"><a href="#3-结构体" class="headerlink" title="3. 结构体"></a>3. 结构体</h1><p>结构体由<code>struct</code>定义，它由不同的字段组成：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该结构体名称是 User，拥有 4 个字段，且每个字段都有对应的字段名及类型声明，例如 username 代表了用户名，是一个可变的 String 类型。</p>
<p>创建一个结构体实例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有几点值得注意:</p>
<ol>
<li>初始化实例时，<strong>每个字段</strong>都需要进行初始化</li>
<li>初始化时的字段顺序<strong>不需要</strong>和结构体定义时的顺序一致</li>
</ol>
<p>通过<code>.</code>即可访问&#x2F;操作结构体字段：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotheremail@example.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>只有将结构体声明为可变的才能修改其字段，rust不允许结构体部分字段可变。</p>
<hr>
<p>rust支持跟TypeScript一样的简化操作：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&amp;gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        <span class="comment">// email: email,</span></span><br><span class="line">        email,</span><br><span class="line">        <span class="comment">// username: username</span></span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以类似与ts解构一个对象(注意这里是两个点，ts是三个点)：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当结构体部分字段所有权被转移时，该结构体将不可用，但是其它字段仍然可用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">    active: user1.active,</span><br><span class="line">    username: user1.username,</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">    sign_in_count: user1.sign_in_count,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, user1.active);</span><br><span class="line"><span class="comment">// 下面这行会报错</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, user1);</span><br></pre></td></tr></table></figure>

<h2 id="3-1-内存体的结构排序"><a href="#3-1-内存体的结构排序" class="headerlink" title="3.1 内存体的结构排序"></a>3.1 内存体的结构排序</h2><p>如下的结构体：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">File</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    data: <span class="type">Vec</span>&amp;lt;<span class="type">u8</span>&amp;gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在内存中的结构为：<br><img lazy="https://selfb.asia/blog/v2-8cc4ed8cd06d60f974d06ca2199b8df5_1440w.png" alt="File内存结构"></p>
<p>从图中可以清晰地看出 File 结构体两个字段 name 和 data 分别拥有底层两个 [u8] 数组的所有权，通过 ptr 指针指向底层数组的内存地址，这里你可以把 ptr 指针理解为 Rust 中的引用类型。</p>
<p>该图片也侧面印证了：<strong>把结构体中具有所有权的字段转移出去后，将无法再访问该字段，但是可以正常访问其它的字段</strong>。</p>
<h2 id="3-2-元组结构体"><a href="#3-2-元组结构体" class="headerlink" title="3.2 元组结构体"></a>3.2 元组结构体</h2><p>结构体必须要有名称，但是结构体的字段可以没有名称，这种结构体长得很像元组，因此被称为元组结构体，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>元组结构体在你希望有一个整体名称，但是又不关心里面字段的名称时将非常有用。例如上面的 Point 元组结构体，众所周知 3D 点是 (x, y, z) 形式的坐标点，因此我们无需再为内部的字段逐一命名为：x, y, z。</p>
<p>注意在解构时需要加上类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">let</span> (r, g, b) = black;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">Color</span>(r, g, b) = black;</span><br></pre></td></tr></table></figure>

<h1 id="4-枚举"><a href="#4-枚举" class="headerlink" title="4. 枚举"></a>4. 枚举</h1><p>枚举(enum 或 enumeration)允许你通过列举可能的成员来定义一个枚举类型，例如扑克牌花色：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">PokerSuit</span> &#123;</span><br><span class="line">  Clubs,</span><br><span class="line">  Spades,</span><br><span class="line">  Diamonds,</span><br><span class="line">  Hearts,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用枚举值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">heart</span> = PokerSuit::Hearts;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">diamond</span> = PokerSuit::Diamonds;</span><br></pre></td></tr></table></figure>

<p>在函数中使用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heart</span> = PokerSuit::Hearts;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">diamond</span> = PokerSuit::Diamonds;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print_suit</span>(heart);</span><br><span class="line">    <span class="title function_ invoke__">print_suit</span>(diamond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_suit</span>(card: PokerSuit) &#123;</span><br><span class="line">    <span class="comment">// 需要在定义 enum PokerSuit 的上面添加上 #[derive(Debug)]，否则会报 card 没有实现 Debug</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,card);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>枚举也可以提供固定的值，但是只能使用<code>isize</code>类型的整型，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">RankScore</span> &#123;</span><br><span class="line">    FIRST = <span class="number">100</span>,</span><br><span class="line">    SECOND = <span class="number">90</span>,</span><br><span class="line">    THIRD = <span class="number">80</span>,</span><br><span class="line">    <span class="comment">// FOURTH会以上面的基础 + 1</span></span><br><span class="line">    FOURTH</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 使用时必须使用as强转为isize或者其它整型</span></span><br><span class="line">    <span class="comment">// THIRD = 80, FOURTH = 81</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;THIRD = &#123;&#125;, FOURTH = &#123;&#125;&quot;</span>, RankScore::THIRD <span class="keyword">as</span> <span class="type">isize</span>, RankScore::FOURTH <span class="keyword">as</span> <span class="type">isize</span>)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><strong>如果没有指定明确的值，则以0开始递增</strong>。</p>
<hr>
<p>在rust中可以给枚举带上类型，例如这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">PokerCard</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Clubs</span>(<span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">Spades</span>(<span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">Diamonds</span>(<span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">Hearts</span>(<span class="type">u8</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">c1</span> = PokerCard::<span class="title function_ invoke__">Spades</span>(<span class="number">5</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">c2</span> = PokerCard::<span class="title function_ invoke__">Diamonds</span>(<span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如标准库中的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Ipv4Addr</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ipv6Addr</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(Ipv4Addr),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(Ipv6Addr),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际使用中，每种枚举字段的类型可以不一样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m1</span> = Message::Quit;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m2</span> = Message::Move&#123;x:<span class="number">1</span>,y:<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m3</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-1-访问枚举值"><a href="#4-1-访问枚举值" class="headerlink" title="4.1 访问枚举值"></a>4.1 访问枚举值</h2><p>如果枚举值自带了类型，访问时则需要使用匹配模式来访问：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::Move&#123;x: <span class="number">1</span>, y: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Message</span>::Move&#123;x: a, y: b&#125; = msg &#123;</span><br><span class="line">        <span class="comment">// use data from Message::Move</span></span><br><span class="line">        <span class="built_in">assert_eq!</span>(a, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// not Message::Move</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在这里无法对<code>msg</code>变量被视作了<code>Message</code>类型，即使创建时使用了<code>Message::Move</code>。如果尝试将<code>msg</code>使用<code>as</code>强转为<code>Message::Move</code>，则会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   |</span><br><span class="line">11 |     let Message::Move &#123; x, y &#125; = msg as Message::Move;</span><br><span class="line">   |                                         ^^^^^^^^^^^^^</span><br><span class="line">   |                                         |</span><br><span class="line">   |                                         not a type</span><br><span class="line">   |                                         help: try using the variant&#x27;s enum: `crate::Message`</span><br></pre></td></tr></table></figure>

<h2 id="4-2-空值"><a href="#4-2-空值" class="headerlink" title="4.2 空值"></a>4.2 空值</h2><p>在Java或其它语言中，<code>null</code>表示一个空值，它可以被赋给任何对象，如果尝试访问一个空对象的任何属性或方法，则会造成空指针异常导致程序崩溃。</p>
<p><strong>因此rust舍弃了空值，而改为使用<code>Option</code>枚举变量来表述这种结果</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&amp;lt;T&amp;gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 T 是泛型参数，Some(T)表示该枚举成员的数据类型是 T，换句话说，Some 可以包含任何类型的数据。</p>
<p><code>Option</code>是被默认导入的(被包含在了rust标准库<code>prelude</code>中)，即不需要显式导入即可使用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">some_number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">some_string</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;a string&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">absent_number</span>: <span class="type">Option</span>&amp;lt;<span class="type">i32</span>&amp;gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure>


<h1 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h1><p>在 Rust 中，最常用的数组有两种，第一种是速度很快但是长度固定的 <code>array</code>，第二种是可动态增长的但是有性能损耗的 <code>Vector</code>。</p>
<h2 id="5-1-创建数组"><a href="#5-1-创建数组" class="headerlink" title="5.1 创建数组"></a>5.1 创建数组</h2><p>创建一个数组:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 效果同上</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化某个值出现N次的数组, [类型; 长度]，只有类型支持Copy的才能使用</span></span><br><span class="line">    <span class="comment">// 长度必须在编译时就已知，不能为动态值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>; <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-访问数组"><a href="#5-2-访问数组" class="headerlink" title="5.2 访问数组"></a>5.2 访问数组</h2><p>数组访问和其它语言一样，使用下标索引访问：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>]; <span class="comment">// 获取a数组第一个元素</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = a[<span class="number">1</span>]; <span class="comment">// 获取第二个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数组长度</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = a.<span class="title function_ invoke__">len</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果出现数组越界异常，则会导致程序崩溃，崩溃是在运行时崩溃，而不是编译期。</p>
<h2 id="5-3-数组切片"><a href="#5-3-数组切片" class="headerlink" title="5.3 数组切片"></a>5.3 数组切片</h2><p>数组切片允许你引用集合中的部分连续片段，而不是整个集合：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span>: &amp;[<span class="type">i32</span>] = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(slice, &amp;[<span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure>

<ul>
<li>切片的长度可以与数组不同，并不是固定的，而是取决于你使用时指定的起始和结束位置</li>
<li>创建切片的代价非常小，因为切片只是针对底层数组的一个引用</li>
<li>切片类型[T]拥有不固定的大小，而切片引用类型&amp;[T]则具有固定的大小，因为 Rust 很多时候都需要固定大小数据类型，因此&amp;[T]更有用,&amp;str字符串切片也同理</li>
</ul>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 IceOfSummerの博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;IceOfSummer
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        
<script
    src="https://giscus.app/client.js"
    data-repo="IceOfSummer/iceofsummer.github.io"
    data-repo-id="R_kgDOJFU7OQ"
    data-category="Announcements"
    data-category-id="DIC_kwDOJFU7Oc4CUyC7"
    data-mapping="title"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin
    async
></script>





        
    </body>
</html>
