
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>从0创建一个nodejs + Typescript项目 | IceOfSummerの博客</title>
        <meta name="author" content="IceOfSummer" />
        <meta name="description" content="后面一辈子的博客都在这了！" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="https://selfb.asia/static/particlex/static/fonts.min.css" />
<script>
  const mixins = {};
  const h = (arg1, arg2, arg3) => {
    if (arg2.attrs) {
      Object.assign(arg2, arg2.attrs)
      Reflect.deleteProperty(arg2, 'attrs')
    }
    if (arg2.on) {
      Object.keys(arg2.on).forEach(key => {
        const head = key.charAt(0).toUpperCase()
        arg2['on' + head  + key.substring(1)] = arg2.on[key]
      })
      Reflect.deleteProperty(arg2, 'on')
    }
    return Vue.h(arg1, arg2, arg3)
  }
</script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

  <script src="/js/lib/toc.js"></script>



  <script src="/js/lib/lazy-load-support.js"></script>


    <meta name="generator" content="Hexo 7.1.1"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存&ensp;浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            </transition>
            <transition name="into">
            <div id="main" v-show="!loading">
                <nav id="menu" ref="menu">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>ICEOFSUMMERの博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" v-show="showMenu" @click="showMenu = !showMenu"></div>
        <div class="title" @click="showMenu = !showMenu">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ICEOFSUMMERの博客</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenu">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

                <div class="article">
    <div>
        <h1>从0创建一个nodejs + Typescript项目</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/1/19
        </span>
        
        
    </div>
    
    <toc-component></toc-component>
    <div class="content" v-pre id="main-content">
        <p>因为踩了很多坑，所以记录一下这个项目是怎么搭的。</p>
<p>最后用了这些东西：</p>
<ul>
<li>Typescript</li>
<li>Webpack(打生产的包)</li>
<li>Eslint</li>
</ul>
<p>因为是nodejs项目，所以这边我还研究了很久怎么在 ts 文件上打断点进行debug，在开发环境下是不会用到 webpack 的。</p>
<p>nodejs版本：18。</p>
<h1 id="1-初始化项目"><a href="#1-初始化项目" class="headerlink" title="1. 初始化项目"></a>1. 初始化项目</h1><p>先<code>npm init</code>创建一个<code>package.json</code>文件，然后安装所需的依赖：</p>
<pre><code class="shell">yarn add eslint @typescript-eslint/parser --dev
yarn add typescript ts-loader ts-node tsconfig-paths --dev
yarn add webpack webpack-cli source-map-support --dev
</code></pre>
<p>之后在<code>package.json</code>里添加<code>&quot;type&quot;: &quot;module&quot;</code>的属性，这样就可以直接在项目里直接使用ESModules了，这个东西在webpack里天生支持按需导入，不需要额外配置(要了解更多的话可以去搜<code>Tree Sharking</code>)。</p>
<h1 id="2-配置eslint"><a href="#2-配置eslint" class="headerlink" title="2. 配置eslint"></a>2. 配置eslint</h1><p>这步比较简单，就直接过了，基本没有什么坑。</p>
<pre><code class="javascript">// .eslintrc.cjs
module.exports = &#123;
  // 下面这行必须加
  parser: &#39;@typescript-eslint/parser&#39;,
  rules: &#123;
    // 这些是我常用的一些规则
    quotes: [&quot;error&quot;, &#39;single&#39;],
    &#39;key-spacing&#39;: [&quot;error&quot;, &#123; &quot;beforeColon&quot;: false &#125;],
    semi: [2, &#39;never&#39;],
    &#39;block-spacing&#39;: &#39;error&#39;,
    &#39;object-curly-spacing&#39;: [&quot;error&quot;, &quot;always&quot;],
    indent: [&#39;error&#39;, 2]
  &#125;,
  // 这里也要加，不然用import会报错
  parserOptions: &#123;
    &quot;ecmaVersion&quot;: 7,
    &quot;sourceType&quot;: &quot;module&quot;
  &#125;
&#125;;
</code></pre>
<h1 id="3-配置Typescript"><a href="#3-配置Typescript" class="headerlink" title="3. 配置Typescript"></a>3. 配置Typescript</h1><p>这里的配置都是可以直接用的，碰到的坑在后面说。</p>
<pre><code class="json">// tsconfig.json
&#123;
  &quot;include&quot;: [&quot;src/**/*.ts&quot;],
  &quot;compilerOptions&quot;: &#123;
    &quot;module&quot;: &quot;esnext&quot;,
    &quot;lib&quot;: [&quot;ES2022&quot;],
    &quot;isolatedModules&quot;: true,
    &quot;esModuleInterop&quot;: true,
    &quot;moduleResolution&quot;: &quot;Bundler&quot;,
    &quot;resolveJsonModule&quot;: true,
    &quot;target&quot;: &quot;ESNext&quot;,
    &quot;strict&quot;: true,
    &quot;allowJs&quot;: true,
    &quot;forceConsistentCasingInFileNames&quot;: true,
    &quot;baseUrl&quot;: &quot;.&quot;,
    &quot;sourceMap&quot;: true,
    &quot;outDir&quot;: &quot;dist/dev&quot;,
    &quot;paths&quot;: &#123;
      // 记住这个别名，待会要考
      &quot;~/*&quot;: [&quot;./src/*&quot;]
    &#125;
  &#125;,
  &quot;ts-node&quot;: &#123;
    &quot;experimentalSpecifierResolution&quot;: &quot;node&quot;,
    &quot;esm&quot;: true,
    &quot;transpileOnly&quot;: true
  &#125;
&#125;
</code></pre>
<h2 id="后缀问题"><a href="#后缀问题" class="headerlink" title="后缀问题"></a>后缀问题</h2><p>这里碰到的第一个坑，就是后缀问题。</p>
<p>这个问题只有在 nodejs + esm 才会有，什么意思呢，来看下面的代码：</p>
<pre><code class="javascript">// ------------------------------------------
// util.ts
export default &quot;hello world&quot;

// ------------------------------------------
// index.ts
import util from &#39;./util&#39;

console.log(util)
</code></pre>
<p>看上去没有什么问题，然后我们用ts-node执行一下：</p>
<pre><code class="shell"> throw new ERR_MODULE_NOT_FOUND(
          ^
CustomError: Cannot find module &#39;xx\src\util&#39; imported from xx\src\index.ts
</code></pre>
<p>如果这个时候你去网上搜，你基本碰到的回答都是让你加上<code>js</code>后缀：</p>
<pre><code class="javascript">// index.ts
import util from &#39;./util.js&#39;

console.log(util)
</code></pre>
<p>首先不说这个<strong>丑的一批</strong>，而且我后面还发现这玩意还会导致另外一个bug：在用webpack打包的时候，如果你加了<code>js</code>后缀，webpack会直接提醒你找不到<code>xx/src/util.js</code>，坑爹呢这不是！</p>
<p>所以肯定是不能加后缀的，然后我也是在网上翻了好久，才找到这个参数：<code>experimentalSpecifierResolution</code>，虽然前面带了个<code>experimental</code>，但其实已经很稳定了，直接在<code>tsconfig.json</code>中添加配置：</p>
<pre><code class="json">&#123;
    // ...
    &quot;ts-node&quot;: &#123;
        // 把值改为node
        &quot;experimentalSpecifierResolution&quot;: &quot;node&quot;,
        // 这个忘了当时为啥要加了，不加好像也不会报错
        &quot;esm&quot;: true
    &#125;
&#125;
</code></pre>
<p>或者使用命令行参数：<code>--experimental-specifier-resolution=node</code>。</p>
<p>加完之后，不带文件后缀也可以成功运行，webpack打包也不会有任何影响。</p>
<h2 id="别名问题"><a href="#别名问题" class="headerlink" title="别名问题"></a>别名问题</h2><p>可以看到我开头提供的<code>tsconfig.json</code>里面有个这样的配置：</p>
<pre><code class="json">&#123;
    &quot;paths&quot;: &#123;
      // 记住这个别名，待会要考
      &quot;~/*&quot;: [&quot;./src/*&quot;]
    &#125;
&#125;
</code></pre>
<p>例如我们有这样的目录结构：</p>
<pre><code class="text">src
├── util
│   └── StringUtils.ts
└── index.ts
</code></pre>
<p>我们在<code>index.ts</code>里面导入<code>StringUtils</code>就可以这样写：</p>
<pre><code class="ts">import StringUtils from &#39;~/util/StringUtils&#39;
</code></pre>
<p>这个功能其实可有可无，但是我就是有强迫症，就是不想用相对路径！</p>
<p>首先啥都不加，直接ts-node运行，居然还报错了：</p>
<pre><code class="shell">throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base));
        ^
CustomError: Cannot find package &#39;~&#39; imported from &#39;xxx/src/index.ts&#39;
</code></pre>
<p>好好好，这都能报错，去查了一下，才知道这玩意是给<code>webpack</code>那些玩意提供声明的：</p>
<pre><code class="javascript">// webpack.config.cjs
module.exports = &#123;
    resolve: &#123;
        extensions: [&#39;.tsx&#39;, &#39;.ts&#39;, &#39;.js&#39;],
        alias: &#123;
            &#39;~&#39;: path.resolve(__dirname, &#39;src&#39;)
        &#125;
    &#125;,
&#125;
</code></pre>
<p>在这里，你只写webpack的别名配置，在 ts 里是会报错的，因为ts才不会管你webpack的配置，所以才需要我们的<code>tsconfig.json</code>来提供一个声明。</p>
<p>行，报错了我就去搜，几下就搜到了，不就是加个<code>tsconfig-paths</code>吗，加上命令行参数：<code>-r tsconfig-paths/register</code>，开跑！</p>
<p>结果万万没想到，又爆了相同的错。。。。</p>
<p>然后又翻了很久的Github（真的很久），终于被我找到了：<a target="_blank" rel="noopener" href="https://github.com/TypeStrong/ts-node/discussions/1450">ESM loader that handles TypeScript path mapping</a>。</p>
<p>复制里面的<code>loader.js</code>，然后修改启动命令为：<code>node --loader ./scripts/loader.js src/index.ts</code>，就可以正常使用别名了。</p>
<h2 id="使用WebStorm调试代码"><a href="#使用WebStorm调试代码" class="headerlink" title="使用WebStorm调试代码"></a>使用WebStorm调试代码</h2><p>因为我们是nodejs项目，肯定是不能少了打断点调试的。</p>
<p>我们可以直接用tsc编译项目为js代码后，直接用Webstorm进行Debug。</p>
<p>因为Webstorm运行js文件基本不需要配置，直接右键点几下就跑起来了。</p>
<p>但是这样很傻批，我们还要分两步进行，而且 ts 文件的变动可能会导致我们在 js 文件上打的断点消失。</p>
<hr>
<p>谢天谢地，Webstorm是真的很聪明(牛逼)，我们只需要简单配置几下就可以直接在 ts 上打断点运行了。</p>
<p><img lazy="https://selfb.asia/blog/20240119235935.png" alt="run configuration"></p>
<p>配完后，直接在ts文件上断点就可以停住。</p>
<h1 id="4-配置Webpack"><a href="#4-配置Webpack" class="headerlink" title="4. 配置Webpack"></a>4. 配置Webpack</h1><p>至于为什么要用 Webpack，是因为我最后不想带着<code>node_modules</code>这个累赘来上生产，最后直接打包成一个文件多爽，直接<code>node xxx.js</code>就跑起来了。</p>
<p>这里是我最后用到的配置：</p>
<pre><code class="javascript">// webpack.config.cjs
const path = require(&#39;path&#39;);
const webpack = require(&#39;webpack&#39;)

module.exports = function (env, args) &#123;
    return &#123;
        entry: &#39;./src/index.js&#39;,
        target: &#39;node&#39;,
        module: &#123;
            rules: [
                &#123;
                    test: /\.tsx?$/,
                    use: &#39;ts-loader&#39;,
                    exclude: /node_modules/,
                &#125;,
            ],
        &#125;,
        resolve: &#123;
            extensions: [&#39;.tsx&#39;, &#39;.ts&#39;, &#39;.js&#39;],
            alias: &#123;
                &#39;~&#39;: path.resolve(__dirname, &#39;src&#39;)
            &#125;
        &#125;,
        output: &#123;
            filename: (pathData) =&gt; &#123;
                return pathData.chunk.name === &#39;main&#39; ? &#39;main.cjs&#39; : &#39;libs.cjs&#39;;
            &#125;,
        &#125;,
        plugins: [
            new webpack.SourceMapDevToolPlugin(&#123;
                exclude: [&#39;libs.cjs&#39;]
            &#125;)
        ],
        optimization: &#123;
            splitChunks: &#123;
                chunks: &#39;all&#39;
            &#125;,
        &#125;,
    &#125;;
&#125;
</code></pre>
<p>注意文件后缀是cjs，不然用<code>module.exports</code>会报错。</p>
<p>打包时直接用<code>webpack --mode=production</code>就可以了。</p>
<h2 id="配置sourcemap"><a href="#配置sourcemap" class="headerlink" title="配置sourcemap"></a>配置sourcemap</h2><p>在Webpack打包后，我们的所有代码都被压缩到一行了，而且变量名都变得六亲不认了，想象一下，假如运行过程中报一个错，你能定位到问题发生在哪吗。。。</p>
<p>所以这个时候我们需要用到 sourcemap 来对我们的代码进行索引。</p>
<p>直接使用 sourcemap 文件是不行的，因为这玩意是给浏览器用到，我们需要导入依赖 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/source-map-support">source-map-support</a> 来加载sourcemap。</p>
<p>这里你可以把 sourcemap 分离成一个单独的文件，也可以让它内嵌到代码里面。</p>
<p>这里我推荐内嵌到代码里面，便于后面代码分发，没必要分出来。</p>
<p>在 Webpack 添加配置<code>devtool: &#39;inline-source-map&#39;</code>。</p>
<p>还没完，也要在<code>tsconfig.json</code>里面添加<code>&quot;sourceMap&quot;: true</code>的配置，如果少了这一步，最终生成的 sourcemap 行数会对不上，因为这个时候 Webpack 只会对编译后的 js 文件来构建索引，而 ts 编译后的文件中，空行(一行什么内容都没有的)会被删除，因此导致行数对不上。</p>
<p>最后在代码入口添加加载的代码：</p>
<pre><code class="typescript">import sourceMapSupport from &#39;source-map-support&#39;

sourceMapSupport.install()
</code></pre>
<h3 id="进一步压缩"><a href="#进一步压缩" class="headerlink" title="进一步压缩"></a>进一步压缩</h3><p>如果你观察生成的文件，会发现生成 sourcemap 会导致文件变得<strong>非常大</strong>，基本会变大 5 ~ 6 倍左右。</p>
<p>如果你把 sourcemap 分成单独的文件，然后打开开一下，会发现 Webpack 也给 <code>node_modules</code> 里面的代码生成了 sourcemap！</p>
<p>作为一个强迫症患者，我是绝对不能忍受这种情况的！</p>
<p>我们肯定是想给自己的代码生成精准的 sourcemap，而第三方库，可以考虑不生成，或者只使用简单的 sourcemap。</p>
<p>翻了一下 Webpack 文档，发现有个 <a target="_blank" rel="noopener" href="https://webpack.js.org/plugins/source-map-dev-tool-plugin/">SourceMapDevToolPlugin</a> 插件可以指定&#x2F;排除为哪些模块生成 sourcemap。</p>
<p>试了一下，在<code>exclude</code>属性里面不管怎么填，都无法忽略掉<code>node_modules</code>。</p>
<p>在查了一下午的文档以及翻看了源码之后，终于知到怎么配了：</p>
<pre><code class="javascript">// webpack.config.cjs
module.exports = &#123;
  output: &#123;
    filename: (pathData) =&gt; &#123;
      return pathData.chunk.name === &#39;main&#39; ? &#39;main.cjs&#39; : &#39;libs.cjs&#39;;
    &#125;,
  &#125;,
  plugins: [
    new webpack.SourceMapDevToolPlugin(&#123;
        exclude: [&#39;libs.cjs&#39;]
    &#125;)
  ],
  optimization: &#123;
    splitChunks: &#123;
        chunks: &#39;all&#39;
    &#125;,
  &#125;,
&#125;
</code></pre>
<p>加上上面的配置，就可以做到把<code>node_modules</code>里面的代码全部打到<code>libs.cjs</code>中，而我们的业务代码全部打到<code>main.cjs</code>中，同时配置我们的<code>SourceMapDevToolPlugin</code>不为<code>libs.cjs</code>生成 sourcemap。</p>
<h1 id="DLC：node20版本"><a href="#DLC：node20版本" class="headerlink" title="DLC：node20版本"></a>DLC：node20版本</h1><p>之前导入模块我们为了省略后缀，在配置中添加了<code>experimentalSpecifierResolution: node</code>参数，在node20上，这个参数仍然可用，但是已经有了更好的替代。</p>
<p>文档：<a target="_blank" rel="noopener" href="https://nodejs.org/api/esm.html#loaders">Loaders</a></p>
<p>并且官方也给了一个样例来代替上面的启动参数：<a target="_blank" rel="noopener" href="https://github.com/nodejs/loaders-test/tree/main/commonjs-extension-resolution-loader">commonjs-extension-resolution-loader</a>。</p>
<p>这里直接摆上我用的代码：</p>
<pre><code class="javascript">// extension-loader.js
/**
 * 处理ts-node导入时必须加后缀
 */
// https://github.com/nodejs/loaders-test/blob/main/commonjs-extension-resolution-loader/loader.js
import &#123; isBuiltin &#125; from &#39;node:module&#39;
import &#123; dirname &#125; from &#39;node:path&#39;
import &#123; cwd &#125; from &#39;node:process&#39;
import &#123; fileURLToPath, pathToFileURL &#125; from &#39;node:url&#39;
import &#123; promisify &#125; from &#39;node:util&#39;

import resolveCallback from &#39;resolve/async.js&#39;

const resolveAsync = promisify(resolveCallback)

const baseURL = pathToFileURL(cwd() + &#39;/&#39;).href


export async function resolve(specifier, context, next) &#123;
  const &#123; parentURL = baseURL &#125; = context

  if (isBuiltin(specifier)) &#123;
    return next(specifier, context)
  &#125;

  // `resolveAsync` works with paths, not URLs
  if (specifier.startsWith(&#39;file://&#39;)) &#123;
    specifier = fileURLToPath(specifier)
  &#125;
  const parentPath = fileURLToPath(parentURL)

  let url
  try &#123;
    const resolution = await resolveAsync(specifier, &#123;
      basedir: dirname(parentPath),
      // For whatever reason, --experimental-specifier-resolution=node doesn&#39;t search for .mjs extensions
      // but it does search for index.mjs files within directories
      extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.node&#39;, &#39;.mjs&#39;, &#39;.ts&#39;],
    &#125;)
    url = pathToFileURL(resolution).href
  &#125; catch (error) &#123;
    if (error.code === &#39;MODULE_NOT_FOUND&#39;) &#123;
      // Match Node&#39;s error code
      error.code = &#39;ERR_MODULE_NOT_FOUND&#39;
    &#125;
    throw error
  &#125;

  return next(url, context)
&#125;
</code></pre>
<pre><code class="javascript">// path-loader.js
/**
 * 处理ts路径别名报错
 */
import &#123; resolve as resolveTs &#125; from &#39;ts-node/esm&#39;
import * as tsConfigPaths from &#39;tsconfig-paths&#39;
import &#123; pathToFileURL &#125; from &#39;url&#39;

const &#123; absoluteBaseUrl, paths &#125; = tsConfigPaths.loadConfig()
const matchPath = tsConfigPaths.createMatchPath(absoluteBaseUrl, paths)

export async function resolve (specifier, ctx, defaultResolve) &#123;
  const match = matchPath(specifier)
  let realPath
  if (match) &#123;
    realPath = pathToFileURL(`$&#123;match&#125;`).href
  &#125; else &#123;
    realPath = specifier
  &#125;
  const r = await defaultResolve(realPath, ctx)
  return resolveTs(r.url, ctx, defaultResolve)
&#125;

export &#123; load, transformSource &#125; from &#39;ts-node/esm&#39;
</code></pre>
<pre><code class="javascript">// register-hooks.js
import &#123; register &#125; from &#39;node:module&#39;

register(&#39;./extension-loader.js&#39;, import.meta.url)
register(&#39;./path-loader.js&#39;, import.meta.url)
</code></pre>
<p>然后把我们的启动命令换成：<code>node --import register-hooks.js src/index.ts</code>。</p>
<p>移除掉<code>tsconfig.json</code>里的<code>experimentalSpecifierResolution</code>，然后就可以正常启动了。</p>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 IceOfSummerの博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;<a target="_blank" rel="noopener" href="https://github.com/IceOfSummer">IceOfSummer</a>
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/IceOfSummer/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        
<script
    src="https://giscus.app/client.js"
    data-repo="IceOfSummer/iceofsummer.github.io"
    data-repo-id="R_kgDOJFU7OQ"
    data-category="Announcements"
    data-category-id="DIC_kwDOJFU7Oc4CUyC7"
    data-mapping="title"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin
    async
></script>





        
    </body>
</html>
